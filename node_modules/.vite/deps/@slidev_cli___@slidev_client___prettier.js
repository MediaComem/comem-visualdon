import {
  __privateAdd,
  __privateMethod,
  __publicField
} from "./chunk-TNDHKS54.js";

// node_modules/prettier/standalone.mjs
var Zn = Object.create;
var Mt = Object.defineProperty;
var eo = Object.getOwnPropertyDescriptor;
var to = Object.getOwnPropertyNames;
var uo = Object.getPrototypeOf;
var ro = Object.prototype.hasOwnProperty;
var no = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var Yt = (e, t) => {
  for (var u in t) Mt(e, u, { get: t[u], enumerable: true });
};
var oo = (e, t, u, r) => {
  if (t && typeof t == "object" || typeof t == "function") for (let o of to(t)) !ro.call(e, o) && o !== u && Mt(e, o, { get: () => t[o], enumerable: !(r = eo(t, o)) || r.enumerable });
  return e;
};
var ao = (e, t, u) => (u = e != null ? Zn(uo(e)) : {}, oo(t || !e || !e.__esModule ? Mt(u, "default", { value: e, enumerable: true }) : u, e));
var dn = no((of, ln) => {
  var yt, bt, At, _t, xt, $e, bu, Ke, Bt, cn, Tt, Ve, Nt, St, wt, pe, fn, Ot, Pt, Aa;
  Nt = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]|[^\/\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
  Ve = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
  yt = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
  wt = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
  Tt = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
  pe = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
  Pt = /[\t\v\f\ufeff\p{Zs}]+/yu;
  Ke = /\r?\n|[\r\u2028\u2029]/y;
  Bt = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
  St = /\/\/.*/y;
  At = /[<>.:={}]|\/(?![\/*])/y;
  bt = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
  _t = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
  xt = /[^<>{}]+/y;
  Ot = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
  fn = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
  $e = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
  bu = /^(?:return|throw|yield)$/;
  cn = RegExp(Ke.source);
  ln.exports = Aa = function* (e, { jsx: t = false } = {}) {
    var u, r, o, n, a, s, i, D, f, l, d, c, p, F;
    for ({ length: s } = e, n = 0, a = "", F = [{ tag: "JS" }], u = [], d = 0, c = false; n < s; ) {
      switch (D = F[F.length - 1], D.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (e[n] === "/" && (Ot.test(a) || $e.test(a)) && (Nt.lastIndex = n, i = Nt.exec(e))) {
            n = Nt.lastIndex, a = i[0], c = true, yield { type: "RegularExpressionLiteral", value: i[0], closed: i[1] !== void 0 && i[1] !== "\\" };
            continue;
          }
          if (Ve.lastIndex = n, i = Ve.exec(e)) {
            switch (p = i[0], f = Ve.lastIndex, l = p, p) {
              case "(":
                a === "?NonExpressionParenKeyword" && F.push({ tag: "JSNonExpressionParen", nesting: d }), d++, c = false;
                break;
              case ")":
                d--, c = true, D.tag === "JSNonExpressionParen" && d === D.nesting && (F.pop(), l = "?NonExpressionParenEnd", c = false);
                break;
              case "{":
                Ve.lastIndex = 0, o = !fn.test(a) && (Ot.test(a) || $e.test(a)), u.push(o), c = false;
                break;
              case "}":
                switch (D.tag) {
                  case "InterpolationInTemplate":
                    if (u.length === D.nesting) {
                      pe.lastIndex = n, i = pe.exec(e), n = pe.lastIndex, a = i[0], i[1] === "${" ? (a = "?InterpolationInTemplate", c = false, yield { type: "TemplateMiddle", value: i[0] }) : (F.pop(), c = true, yield { type: "TemplateTail", value: i[0], closed: i[1] === "`" });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (u.length === D.nesting) {
                      F.pop(), n += 1, a = "}", yield { type: "JSXPunctuator", value: "}" };
                      continue;
                    }
                }
                c = u.pop(), l = c ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                c = true;
                break;
              case "++":
              case "--":
                l = c ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (t && (Ot.test(a) || $e.test(a))) {
                  F.push({ tag: "JSXTag" }), n += 1, a = "<", yield { type: "JSXPunctuator", value: p };
                  continue;
                }
                c = false;
                break;
              default:
                c = false;
            }
            n = f, a = l, yield { type: "Punctuator", value: p };
            continue;
          }
          if (yt.lastIndex = n, i = yt.exec(e)) {
            switch (n = yt.lastIndex, l = i[0], i[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                a !== "." && a !== "?." && (l = "?NonExpressionParenKeyword");
            }
            a = l, c = !$e.test(i[0]), yield { type: i[1] === "#" ? "PrivateIdentifier" : "IdentifierName", value: i[0] };
            continue;
          }
          if (wt.lastIndex = n, i = wt.exec(e)) {
            n = wt.lastIndex, a = i[0], c = true, yield { type: "StringLiteral", value: i[0], closed: i[2] !== void 0 };
            continue;
          }
          if (Tt.lastIndex = n, i = Tt.exec(e)) {
            n = Tt.lastIndex, a = i[0], c = true, yield { type: "NumericLiteral", value: i[0] };
            continue;
          }
          if (pe.lastIndex = n, i = pe.exec(e)) {
            n = pe.lastIndex, a = i[0], i[1] === "${" ? (a = "?InterpolationInTemplate", F.push({ tag: "InterpolationInTemplate", nesting: u.length }), c = false, yield { type: "TemplateHead", value: i[0] }) : (c = true, yield { type: "NoSubstitutionTemplate", value: i[0], closed: i[1] === "`" });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (At.lastIndex = n, i = At.exec(e)) {
            switch (n = At.lastIndex, l = i[0], i[0]) {
              case "<":
                F.push({ tag: "JSXTag" });
                break;
              case ">":
                F.pop(), a === "/" || D.tag === "JSXTagEnd" ? (l = "?JSX", c = true) : F.push({ tag: "JSXChildren" });
                break;
              case "{":
                F.push({ tag: "InterpolationInJSX", nesting: u.length }), l = "?InterpolationInJSX", c = false;
                break;
              case "/":
                a === "<" && (F.pop(), F[F.length - 1].tag === "JSXChildren" && F.pop(), F.push({ tag: "JSXTagEnd" }));
            }
            a = l, yield { type: "JSXPunctuator", value: i[0] };
            continue;
          }
          if (bt.lastIndex = n, i = bt.exec(e)) {
            n = bt.lastIndex, a = i[0], yield { type: "JSXIdentifier", value: i[0] };
            continue;
          }
          if (_t.lastIndex = n, i = _t.exec(e)) {
            n = _t.lastIndex, a = i[0], yield { type: "JSXString", value: i[0], closed: i[2] !== void 0 };
            continue;
          }
          break;
        case "JSXChildren":
          if (xt.lastIndex = n, i = xt.exec(e)) {
            n = xt.lastIndex, a = i[0], yield { type: "JSXText", value: i[0] };
            continue;
          }
          switch (e[n]) {
            case "<":
              F.push({ tag: "JSXTag" }), n++, a = "<", yield { type: "JSXPunctuator", value: "<" };
              continue;
            case "{":
              F.push({ tag: "InterpolationInJSX", nesting: u.length }), n++, a = "?InterpolationInJSX", c = false, yield { type: "JSXPunctuator", value: "{" };
              continue;
          }
      }
      if (Pt.lastIndex = n, i = Pt.exec(e)) {
        n = Pt.lastIndex, yield { type: "WhiteSpace", value: i[0] };
        continue;
      }
      if (Ke.lastIndex = n, i = Ke.exec(e)) {
        n = Ke.lastIndex, c = false, bu.test(a) && (a = "?NoLineTerminatorHere"), yield { type: "LineTerminatorSequence", value: i[0] };
        continue;
      }
      if (Bt.lastIndex = n, i = Bt.exec(e)) {
        n = Bt.lastIndex, cn.test(i[0]) && (c = false, bu.test(a) && (a = "?NoLineTerminatorHere")), yield { type: "MultiLineComment", value: i[0], closed: i[1] !== void 0 };
        continue;
      }
      if (St.lastIndex = n, i = St.exec(e)) {
        n = St.lastIndex, c = false, yield { type: "SingleLineComment", value: i[0] };
        continue;
      }
      r = String.fromCodePoint(e.codePointAt(n)), n += r.length, a = r, c = false, yield { type: D.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid", value: r };
    }
  };
});
var Hn = {};
Yt(Hn, { __debug: () => li, check: () => ci, doc: () => wu, format: () => Jn, formatWithCursor: () => zn, getSupportInfo: () => fi, util: () => Pu, version: () => Mn });
var X = (e, t) => (u, r, ...o) => u | 1 && r == null ? void 0 : (t.call(r) ?? r[e]).apply(r, o);
var io = String.prototype.replaceAll ?? function(e, t) {
  return e.global ? this.replace(e, t) : this.split(e).join(t);
};
var so = X("replaceAll", function() {
  if (typeof this == "string") return io;
});
var oe = so;
var Ne = class {
  diff(t, u, r = {}) {
    let o;
    typeof r == "function" ? (o = r, r = {}) : "callback" in r && (o = r.callback);
    let n = this.castInput(t, r), a = this.castInput(u, r), s = this.removeEmpty(this.tokenize(n, r)), i = this.removeEmpty(this.tokenize(a, r));
    return this.diffWithOptionsObj(s, i, r, o);
  }
  diffWithOptionsObj(t, u, r, o) {
    var n;
    let a = (m) => {
      if (m = this.postProcess(m, r), o) {
        setTimeout(function() {
          o(m);
        }, 0);
        return;
      } else return m;
    }, s = u.length, i = t.length, D = 1, f = s + i;
    r.maxEditLength != null && (f = Math.min(f, r.maxEditLength));
    let l = (n = r.timeout) !== null && n !== void 0 ? n : 1 / 0, d = Date.now() + l, c = [{ oldPos: -1, lastComponent: void 0 }], p = this.extractCommon(c[0], u, t, 0, r);
    if (c[0].oldPos + 1 >= i && p + 1 >= s) return a(this.buildValues(c[0].lastComponent, u, t));
    let F = -1 / 0, C = 1 / 0, y = () => {
      for (let m = Math.max(F, -D); m <= Math.min(C, D); m += 2) {
        let h, E = c[m - 1], g = c[m + 1];
        E && (c[m - 1] = void 0);
        let A = false;
        if (g) {
          let Q = g.oldPos - m;
          A = g && 0 <= Q && Q < s;
        }
        let J = E && E.oldPos + 1 < i;
        if (!A && !J) {
          c[m] = void 0;
          continue;
        }
        if (!J || A && E.oldPos < g.oldPos ? h = this.addToPath(g, true, false, 0, r) : h = this.addToPath(E, false, true, 1, r), p = this.extractCommon(h, u, t, m, r), h.oldPos + 1 >= i && p + 1 >= s) return a(this.buildValues(h.lastComponent, u, t)) || true;
        c[m] = h, h.oldPos + 1 >= i && (C = Math.min(C, m - 1)), p + 1 >= s && (F = Math.max(F, m + 1));
      }
      D++;
    };
    if (o) (function m() {
      setTimeout(function() {
        if (D > f || Date.now() > d) return o(void 0);
        y() || m();
      }, 0);
    })();
    else for (; D <= f && Date.now() <= d; ) {
      let m = y();
      if (m) return m;
    }
  }
  addToPath(t, u, r, o, n) {
    let a = t.lastComponent;
    return a && !n.oneChangePerToken && a.added === u && a.removed === r ? { oldPos: t.oldPos + o, lastComponent: { count: a.count + 1, added: u, removed: r, previousComponent: a.previousComponent } } : { oldPos: t.oldPos + o, lastComponent: { count: 1, added: u, removed: r, previousComponent: a } };
  }
  extractCommon(t, u, r, o, n) {
    let a = u.length, s = r.length, i = t.oldPos, D = i - o, f = 0;
    for (; D + 1 < a && i + 1 < s && this.equals(r[i + 1], u[D + 1], n); ) D++, i++, f++, n.oneChangePerToken && (t.lastComponent = { count: 1, previousComponent: t.lastComponent, added: false, removed: false });
    return f && !n.oneChangePerToken && (t.lastComponent = { count: f, previousComponent: t.lastComponent, added: false, removed: false }), t.oldPos = i, D;
  }
  equals(t, u, r) {
    return r.comparator ? r.comparator(t, u) : t === u || !!r.ignoreCase && t.toLowerCase() === u.toLowerCase();
  }
  removeEmpty(t) {
    let u = [];
    for (let r = 0; r < t.length; r++) t[r] && u.push(t[r]);
    return u;
  }
  castInput(t, u) {
    return t;
  }
  tokenize(t, u) {
    return Array.from(t);
  }
  join(t) {
    return t.join("");
  }
  postProcess(t, u) {
    return t;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(t, u, r) {
    let o = [], n;
    for (; t; ) o.push(t), n = t.previousComponent, delete t.previousComponent, t = n;
    o.reverse();
    let a = o.length, s = 0, i = 0, D = 0;
    for (; s < a; s++) {
      let f = o[s];
      if (f.removed) f.value = this.join(r.slice(D, D + f.count)), D += f.count;
      else {
        if (!f.added && this.useLongestToken) {
          let l = u.slice(i, i + f.count);
          l = l.map(function(d, c) {
            let p = r[D + c];
            return p.length > d.length ? p : d;
          }), f.value = this.join(l);
        } else f.value = this.join(u.slice(i, i + f.count));
        i += f.count, f.added || (D += f.count);
      }
    }
    return o;
  }
};
var jt = class extends Ne {
  tokenize(t) {
    return t.slice();
  }
  join(t) {
    return t;
  }
  removeEmpty(t) {
    return t;
  }
};
var ku = new jt();
function Ut(e, t, u) {
  return ku.diff(e, t, u);
}
var Do = () => {
};
var P = Do;
var Ru = "cr";
var Lu = "crlf";
var co = "lf";
var fo = co;
var Wt = "\r";
var Mu = `\r
`;
var Je = `
`;
var lo = Je;
function Yu(e) {
  let t = e.indexOf(Wt);
  return t !== -1 ? e.charAt(t + 1) === Je ? Lu : Ru : fo;
}
function Se(e) {
  return e === Ru ? Wt : e === Lu ? Mu : lo;
}
var po = /* @__PURE__ */ new Map([[Je, /\n/gu], [Wt, /\r/gu], [Mu, /\r\n/gu]]);
function $t(e, t) {
  var _a3;
  let u = po.get(t);
  return ((_a3 = e.match(u)) == null ? void 0 : _a3.length) ?? 0;
}
var Fo = /\r\n?/gu;
function ju(e) {
  return oe(0, e, Fo, Je);
}
function mo(e) {
  return this[e < 0 ? this.length + e : e];
}
var Eo = X("at", function() {
  if (Array.isArray(this) || typeof this == "string") return mo;
});
var b = Eo;
var G = "string";
var j = "array";
var U = "cursor";
var I = "indent";
var k = "align";
var v = "trim";
var x = "group";
var w = "fill";
var B = "if-break";
var R = "indent-if-break";
var L = "line-suffix";
var M = "line-suffix-boundary";
var _ = "line";
var O = "label";
var T = "break-parent";
var He = /* @__PURE__ */ new Set([U, I, k, v, x, w, B, R, L, M, _, O, T]);
function Uu(e) {
  let t = e.length;
  for (; t > 0 && (e[t - 1] === "\r" || e[t - 1] === `
`); ) t--;
  return t < e.length ? e.slice(0, t) : e;
}
function Co(e) {
  if (typeof e == "string") return G;
  if (Array.isArray(e)) return j;
  if (!e) return;
  let { type: t } = e;
  if (He.has(t)) return t;
}
var H = Co;
var ho = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
function go(e) {
  let t = e === null ? "null" : typeof e;
  if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
  if (H(e)) throw new Error("doc is valid.");
  let u = Object.prototype.toString.call(e);
  if (u !== "[object Object]") return `Unexpected doc '${u}'.`;
  let r = ho([...He].map((o) => `'${o}'`));
  return `Unexpected doc.type '${e.type}'.
Expected it to be ${r}.`;
}
var Vt = class extends Error {
  constructor(t) {
    super(go(t));
    __publicField(this, "name", "InvalidDocError");
    this.doc = t;
  }
};
var Z = Vt;
var Wu = {};
function yo(e, t, u, r) {
  let o = [e];
  for (; o.length > 0; ) {
    let n = o.pop();
    if (n === Wu) {
      u(o.pop());
      continue;
    }
    u && o.push(n, Wu);
    let a = H(n);
    if (!a) throw new Z(n);
    if ((t == null ? void 0 : t(n)) !== false) switch (a) {
      case j:
      case w: {
        let s = a === j ? n : n.parts;
        for (let i = s.length, D = i - 1; D >= 0; --D) o.push(s[D]);
        break;
      }
      case B:
        o.push(n.flatContents, n.breakContents);
        break;
      case x:
        if (r && n.expandedStates) for (let s = n.expandedStates.length, i = s - 1; i >= 0; --i) o.push(n.expandedStates[i]);
        else o.push(n.contents);
        break;
      case k:
      case I:
      case R:
      case O:
      case L:
        o.push(n.contents);
        break;
      case G:
      case U:
      case v:
      case M:
      case _:
      case T:
        break;
      default:
        throw new Z(n);
    }
  }
}
var we = yo;
function Pe(e, t) {
  if (typeof e == "string") return t(e);
  let u = /* @__PURE__ */ new Map();
  return r(e);
  function r(n) {
    if (u.has(n)) return u.get(n);
    let a = o(n);
    return u.set(n, a), a;
  }
  function o(n) {
    switch (H(n)) {
      case j:
        return t(n.map(r));
      case w:
        return t({ ...n, parts: n.parts.map(r) });
      case B:
        return t({ ...n, breakContents: r(n.breakContents), flatContents: r(n.flatContents) });
      case x: {
        let { expandedStates: a, contents: s } = n;
        return a ? (a = a.map(r), s = a[0]) : s = r(s), t({ ...n, contents: s, expandedStates: a });
      }
      case k:
      case I:
      case R:
      case O:
      case L:
        return t({ ...n, contents: r(n.contents) });
      case G:
      case U:
      case v:
      case M:
      case _:
      case T:
        return t(n);
      default:
        throw new Z(n);
    }
  }
}
function Xe(e, t, u) {
  let r = u, o = false;
  function n(a) {
    if (o) return false;
    let s = t(a);
    s !== void 0 && (o = true, r = s);
  }
  return we(e, n), r;
}
function bo(e) {
  if (e.type === x && e.break || e.type === _ && e.hard || e.type === T) return true;
}
function Ku(e) {
  return Xe(e, bo, false);
}
function $u(e) {
  if (e.length > 0) {
    let t = b(0, e, -1);
    !t.expandedStates && !t.break && (t.break = "propagated");
  }
  return null;
}
function Gu(e) {
  let t = /* @__PURE__ */ new Set(), u = [];
  function r(n) {
    if (n.type === T && $u(u), n.type === x) {
      if (u.push(n), t.has(n)) return false;
      t.add(n);
    }
  }
  function o(n) {
    n.type === x && u.pop().break && $u(u);
  }
  we(e, r, o, true);
}
function Ao(e) {
  return e.type === _ && !e.hard ? e.soft ? "" : " " : e.type === B ? e.flatContents : e;
}
function zu(e) {
  return Pe(e, Ao);
}
function Vu(e) {
  for (e = [...e]; e.length >= 2 && b(0, e, -2).type === _ && b(0, e, -1).type === T; ) e.length -= 2;
  if (e.length > 0) {
    let t = Oe(b(0, e, -1));
    e[e.length - 1] = t;
  }
  return e;
}
function Oe(e) {
  switch (H(e)) {
    case I:
    case R:
    case x:
    case L:
    case O: {
      let t = Oe(e.contents);
      return { ...e, contents: t };
    }
    case B:
      return { ...e, breakContents: Oe(e.breakContents), flatContents: Oe(e.flatContents) };
    case w:
      return { ...e, parts: Vu(e.parts) };
    case j:
      return Vu(e);
    case G:
      return Uu(e);
    case k:
    case U:
    case v:
    case M:
    case _:
    case T:
      break;
    default:
      throw new Z(e);
  }
  return e;
}
function qe(e) {
  return Oe(xo(e));
}
function _o(e) {
  switch (H(e)) {
    case w:
      if (e.parts.every((t) => t === "")) return "";
      break;
    case x:
      if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
      if (e.contents.type === x && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
      break;
    case k:
    case I:
    case R:
    case L:
      if (!e.contents) return "";
      break;
    case B:
      if (!e.flatContents && !e.breakContents) return "";
      break;
    case j: {
      let t = [];
      for (let u of e) {
        if (!u) continue;
        let [r, ...o] = Array.isArray(u) ? u : [u];
        typeof r == "string" && typeof b(0, t, -1) == "string" ? t[t.length - 1] += r : t.push(r), t.push(...o);
      }
      return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
    }
    case G:
    case U:
    case v:
    case M:
    case _:
    case O:
    case T:
      break;
    default:
      throw new Z(e);
  }
  return e;
}
function xo(e) {
  return Pe(e, (t) => _o(t));
}
function Ju(e, t = Qe) {
  return Pe(e, (u) => typeof u == "string" ? Ie(t, u.split(`
`)) : u);
}
function Bo(e) {
  if (e.type === _) return true;
}
function Hu(e) {
  return Xe(e, Bo, false);
}
function Ee(e, t) {
  return e.type === O ? { ...e, contents: t(e.contents) } : t(e);
}
var N = P;
var Ze = P;
var Xu = P;
var qu = P;
function ae(e) {
  return N(e), { type: I, contents: e };
}
function De(e, t) {
  return qu(e), N(t), { type: k, contents: t, n: e };
}
function Qu(e) {
  return De(Number.NEGATIVE_INFINITY, e);
}
function et(e) {
  return De({ type: "root" }, e);
}
function Zu(e) {
  return De(-1, e);
}
function tt(e, t, u) {
  N(e);
  let r = e;
  if (t > 0) {
    for (let o = 0; o < Math.floor(t / u); ++o) r = ae(r);
    r = De(t % u, r), r = De(Number.NEGATIVE_INFINITY, r);
  }
  return r;
}
var ce = { type: T };
var ee = { type: U };
function er(e) {
  return Xu(e), { type: w, parts: e };
}
function Kt(e, t = {}) {
  return N(e), Ze(t.expandedStates, true), { type: x, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
}
function tr(e, t) {
  return Kt(e[0], { ...t, expandedStates: e });
}
function ur(e, t = "", u = {}) {
  return N(e), t !== "" && N(t), { type: B, breakContents: e, flatContents: t, groupId: u.groupId };
}
function rr(e, t) {
  return N(e), { type: R, contents: e, groupId: t.groupId, negate: t.negate };
}
function Ie(e, t) {
  N(e), Ze(t);
  let u = [];
  for (let r = 0; r < t.length; r++) r !== 0 && u.push(e), u.push(t[r]);
  return u;
}
function nr(e, t) {
  return N(t), e ? { type: O, label: e, contents: t } : t;
}
var ut = { type: _ };
var or = { type: _, soft: true };
var ke = { type: _, hard: true };
var V = [ke, ce];
var Gt = { type: _, hard: true, literal: true };
var Qe = [Gt, ce];
function ve(e) {
  return N(e), { type: L, contents: e };
}
var ar = { type: M };
var ir = { type: v };
function te(e) {
  var _a3;
  if (!e) return "";
  if (Array.isArray(e)) {
    let t = [];
    for (let u of e) if (Array.isArray(u)) t.push(...te(u));
    else {
      let r = te(u);
      r !== "" && t.push(r);
    }
    return t;
  }
  return e.type === B ? { ...e, breakContents: te(e.breakContents), flatContents: te(e.flatContents) } : e.type === x ? { ...e, contents: te(e.contents), expandedStates: (_a3 = e.expandedStates) == null ? void 0 : _a3.map(te) } : e.type === w ? { type: "fill", parts: e.parts.map(te) } : e.contents ? { ...e, contents: te(e.contents) } : e;
}
function sr(e) {
  let t = /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ new Set();
  return r(te(e));
  function r(n, a, s) {
    var _a3, _b;
    if (typeof n == "string") return JSON.stringify(n);
    if (Array.isArray(n)) {
      let i = n.map(r).filter(Boolean);
      return i.length === 1 ? i[0] : `[${i.join(", ")}]`;
    }
    if (n.type === _) {
      let i = ((_a3 = s == null ? void 0 : s[a + 1]) == null ? void 0 : _a3.type) === T;
      return n.literal ? i ? "literalline" : "literallineWithoutBreakParent" : n.hard ? i ? "hardline" : "hardlineWithoutBreakParent" : n.soft ? "softline" : "line";
    }
    if (n.type === T) return ((_b = s == null ? void 0 : s[a - 1]) == null ? void 0 : _b.type) === _ && s[a - 1].hard ? void 0 : "breakParent";
    if (n.type === v) return "trim";
    if (n.type === I) return "indent(" + r(n.contents) + ")";
    if (n.type === k) return n.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + r(n.contents) + ")" : n.n < 0 ? "dedent(" + r(n.contents) + ")" : n.n.type === "root" ? "markAsRoot(" + r(n.contents) + ")" : "align(" + JSON.stringify(n.n) + ", " + r(n.contents) + ")";
    if (n.type === B) return "ifBreak(" + r(n.breakContents) + (n.flatContents ? ", " + r(n.flatContents) : "") + (n.groupId ? (n.flatContents ? "" : ', ""') + `, { groupId: ${o(n.groupId)} }` : "") + ")";
    if (n.type === R) {
      let i = [];
      n.negate && i.push("negate: true"), n.groupId && i.push(`groupId: ${o(n.groupId)}`);
      let D = i.length > 0 ? `, { ${i.join(", ")} }` : "";
      return `indentIfBreak(${r(n.contents)}${D})`;
    }
    if (n.type === x) {
      let i = [];
      n.break && n.break !== "propagated" && i.push("shouldBreak: true"), n.id && i.push(`id: ${o(n.id)}`);
      let D = i.length > 0 ? `, { ${i.join(", ")} }` : "";
      return n.expandedStates ? `conditionalGroup([${n.expandedStates.map((f) => r(f)).join(",")}]${D})` : `group(${r(n.contents)}${D})`;
    }
    if (n.type === w) return `fill([${n.parts.map((i) => r(i)).join(", ")}])`;
    if (n.type === L) return "lineSuffix(" + r(n.contents) + ")";
    if (n.type === M) return "lineSuffixBoundary";
    if (n.type === O) return `label(${JSON.stringify(n.label)}, ${r(n.contents)})`;
    if (n.type === U) return "cursor";
    throw new Error("Unknown doc type " + n.type);
  }
  function o(n) {
    if (typeof n != "symbol") return JSON.stringify(String(n));
    if (n in t) return t[n];
    let a = n.description || "symbol";
    for (let s = 0; ; s++) {
      let i = a + (s > 0 ? ` #${s}` : "");
      if (!u.has(i)) return u.add(i), t[n] = `Symbol.for(${JSON.stringify(i)})`;
    }
  }
}
var Dr = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function zt(e) {
  return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
}
function Jt(e) {
  return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e >= 94192 && e <= 94198 || e >= 94208 && e <= 101589 || e >= 101631 && e <= 101662 || e >= 101760 && e <= 101874 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128728 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129674 || e >= 129678 && e <= 129734 || e === 129736 || e >= 129741 && e <= 129756 || e >= 129759 && e <= 129770 || e >= 129775 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
}
var cr = "©®‼⁉™ℹ↔↕↖↗↘↙↩↪⌨⏏⏱⏲⏸⏹⏺▪▫▶◀◻◼☀☁☂☃☄☎☑☘☝☠☢☣☦☪☮☯☸☹☺♀♂♟♠♣♥♦♨♻♾⚒⚔⚕⚖⚗⚙⚛⚜⚠⚧⚰⚱⛈⛏⛑⛓⛩⛱⛷⛸⛹✂✈✉✌✍✏✒✔✖✝✡✳✴❄❇❣❤➡⤴⤵⬅⬆⬇";
var To = /[^\x20-\x7F]/u;
var No = new Set(cr);
function So(e) {
  if (!e) return 0;
  if (!To.test(e)) return e.length;
  e = e.replace(Dr(), (u) => No.has(u) ? " " : "  ");
  let t = 0;
  for (let u of e) {
    let r = u.codePointAt(0);
    r <= 31 || r >= 127 && r <= 159 || r >= 768 && r <= 879 || r >= 65024 && r <= 65039 || (t += zt(r) || Jt(r) ? 2 : 1);
  }
  return t;
}
var Re = So;
var wo = { type: 0 };
var Oo = { type: 1 };
var Ht = { value: "", length: 0, queue: [], get root() {
  return Ht;
} };
function fr(e, t, u) {
  let r = t.type === 1 ? e.queue.slice(0, -1) : [...e.queue, t], o = "", n = 0, a = 0, s = 0;
  for (let p of r) switch (p.type) {
    case 0:
      f(), u.useTabs ? i(1) : D(u.tabWidth);
      break;
    case 3: {
      let { string: F } = p;
      f(), o += F, n += F.length;
      break;
    }
    case 2: {
      let { width: F } = p;
      a += 1, s += F;
      break;
    }
    default:
      throw new Error(`Unexpected indent comment '${p.type}'.`);
  }
  return d(), { ...e, value: o, length: n, queue: r };
  function i(p) {
    o += "	".repeat(p), n += u.tabWidth * p;
  }
  function D(p) {
    o += " ".repeat(p), n += p;
  }
  function f() {
    u.useTabs ? l() : d();
  }
  function l() {
    a > 0 && i(a), c();
  }
  function d() {
    s > 0 && D(s), c();
  }
  function c() {
    a = 0, s = 0;
  }
}
function lr(e, t, u) {
  if (!t) return e;
  if (t.type === "root") return { ...e, root: e };
  if (t === Number.NEGATIVE_INFINITY) return e.root;
  let r;
  return typeof t == "number" ? t < 0 ? r = Oo : r = { type: 2, width: t } : r = { type: 3, string: t }, fr(e, r, u);
}
function dr(e, t) {
  return fr(e, wo, t);
}
function Po(e) {
  let t = 0;
  for (let u = e.length - 1; u >= 0; u--) {
    let r = e[u];
    if (r === " " || r === "	") t++;
    else break;
  }
  return t;
}
function Xt(e) {
  let t = Po(e);
  return { text: t === 0 ? e : e.slice(0, e.length - t), count: t };
}
var W = Symbol("MODE_BREAK");
var q = Symbol("MODE_FLAT");
var qt = Symbol("DOC_FILL_PRINTED_LENGTH");
function rt(e, t, u, r, o, n) {
  if (u === Number.POSITIVE_INFINITY) return true;
  let a = t.length, s = false, i = [e], D = "";
  for (; u >= 0; ) {
    if (i.length === 0) {
      if (a === 0) return true;
      i.push(t[--a]);
      continue;
    }
    let { mode: f, doc: l } = i.pop(), d = H(l);
    switch (d) {
      case G:
        l && (s && (D += " ", u -= 1, s = false), D += l, u -= Re(l));
        break;
      case j:
      case w: {
        let c = d === j ? l : l.parts, p = l[qt] ?? 0;
        for (let F = c.length - 1; F >= p; F--) i.push({ mode: f, doc: c[F] });
        break;
      }
      case I:
      case k:
      case R:
      case O:
        i.push({ mode: f, doc: l.contents });
        break;
      case v: {
        let { text: c, count: p } = Xt(D);
        D = c, u += p;
        break;
      }
      case x: {
        if (n && l.break) return false;
        let c = l.break ? W : f, p = l.expandedStates && c === W ? b(0, l.expandedStates, -1) : l.contents;
        i.push({ mode: c, doc: p });
        break;
      }
      case B: {
        let p = (l.groupId ? o[l.groupId] || q : f) === W ? l.breakContents : l.flatContents;
        p && i.push({ mode: f, doc: p });
        break;
      }
      case _:
        if (f === W || l.hard) return true;
        l.soft || (s = true);
        break;
      case L:
        r = true;
        break;
      case M:
        if (r) return false;
        break;
    }
  }
  return false;
}
function Ce(e, t) {
  let u = /* @__PURE__ */ Object.create(null), r = t.printWidth, o = Se(t.endOfLine), n = 0, a = [{ indent: Ht, mode: W, doc: e }], s = "", i = false, D = [], f = [], l = [], d = [], c = 0;
  for (Gu(e); a.length > 0; ) {
    let { indent: m, mode: h, doc: E } = a.pop();
    switch (H(E)) {
      case G: {
        let g = o !== `
` ? oe(0, E, `
`, o) : E;
        g && (s += g, a.length > 0 && (n += Re(g)));
        break;
      }
      case j:
        for (let g = E.length - 1; g >= 0; g--) a.push({ indent: m, mode: h, doc: E[g] });
        break;
      case U:
        if (f.length >= 2) throw new Error("There are too many 'cursor' in doc.");
        f.push(c + s.length);
        break;
      case I:
        a.push({ indent: dr(m, t), mode: h, doc: E.contents });
        break;
      case k:
        a.push({ indent: lr(m, E.n, t), mode: h, doc: E.contents });
        break;
      case v:
        y();
        break;
      case x:
        switch (h) {
          case q:
            if (!i) {
              a.push({ indent: m, mode: E.break ? W : q, doc: E.contents });
              break;
            }
          case W: {
            i = false;
            let g = { indent: m, mode: q, doc: E.contents }, A = r - n, J = D.length > 0;
            if (!E.break && rt(g, a, A, J, u)) a.push(g);
            else if (E.expandedStates) {
              let Q = b(0, E.expandedStates, -1);
              if (E.break) {
                a.push({ indent: m, mode: W, doc: Q });
                break;
              } else for (let re = 1; re < E.expandedStates.length + 1; re++) if (re >= E.expandedStates.length) {
                a.push({ indent: m, mode: W, doc: Q });
                break;
              } else {
                let Te = E.expandedStates[re], ne = { indent: m, mode: q, doc: Te };
                if (rt(ne, a, A, J, u)) {
                  a.push(ne);
                  break;
                }
              }
            } else a.push({ indent: m, mode: W, doc: E.contents });
            break;
          }
        }
        E.id && (u[E.id] = b(0, a, -1).mode);
        break;
      case w: {
        let g = r - n, A = E[qt] ?? 0, { parts: J } = E, Q = J.length - A;
        if (Q === 0) break;
        let re = J[A + 0], Te = J[A + 1], ne = { indent: m, mode: q, doc: re }, vt = { indent: m, mode: W, doc: re }, Rt = rt(ne, [], g, D.length > 0, u, true);
        if (Q === 1) {
          Rt ? a.push(ne) : a.push(vt);
          break;
        }
        let Iu = { indent: m, mode: q, doc: Te }, Lt = { indent: m, mode: W, doc: Te };
        if (Q === 2) {
          Rt ? a.push(Iu, ne) : a.push(Lt, vt);
          break;
        }
        let Xn = J[A + 2], qn = { indent: m, mode: h, doc: { ...E, [qt]: A + 2 } }, Qn = rt({ indent: m, mode: q, doc: [re, Te, Xn] }, [], g, D.length > 0, u, true);
        a.push(qn), Qn ? a.push(Iu, ne) : Rt ? a.push(Lt, ne) : a.push(Lt, vt);
        break;
      }
      case B:
      case R: {
        let g = E.groupId ? u[E.groupId] : h;
        if (g === W) {
          let A = E.type === B ? E.breakContents : E.negate ? E.contents : ae(E.contents);
          A && a.push({ indent: m, mode: h, doc: A });
        }
        if (g === q) {
          let A = E.type === B ? E.flatContents : E.negate ? ae(E.contents) : E.contents;
          A && a.push({ indent: m, mode: h, doc: A });
        }
        break;
      }
      case L:
        D.push({ indent: m, mode: h, doc: E.contents });
        break;
      case M:
        D.length > 0 && a.push({ indent: m, mode: h, doc: ke });
        break;
      case _:
        switch (h) {
          case q:
            if (E.hard) i = true;
            else {
              E.soft || (s += " ", n += 1);
              break;
            }
          case W:
            if (D.length > 0) {
              a.push({ indent: m, mode: h, doc: E }, ...D.reverse()), D.length = 0;
              break;
            }
            E.literal ? (s += o, n = 0, m.root && (m.root.value && (s += m.root.value), n = m.root.length)) : (y(), s += o + m.value, n = m.length);
            break;
        }
        break;
      case O:
        a.push({ indent: m, mode: h, doc: E.contents });
        break;
      case T:
        break;
      default:
        throw new Z(E);
    }
    a.length === 0 && D.length > 0 && (a.push(...D.reverse()), D.length = 0);
  }
  let p = l.join("") + s, F = [...d, ...f];
  if (F.length !== 2) return { formatted: p };
  let C = F[0];
  return { formatted: p, cursorNodeStart: C, cursorNodeText: p.slice(C, b(0, F, -1)) };
  function y() {
    let { text: m, count: h } = Xt(s);
    m && (l.push(m), c += m.length), s = "", n -= h, f.length > 0 && (d.push(...f.map((E) => Math.min(E, c))), f.length = 0);
  }
}
function Io(e, t, u = 0) {
  let r = 0;
  for (let o = u; o < e.length; ++o) e[o] === "	" ? r = r + t - r % t : r++;
  return r;
}
var he = Io;
var _Qt_instances, t_fn, e_fn, _a;
var Qt = (_a = class {
  constructor(t) {
    __privateAdd(this, _Qt_instances);
    this.stack = [t];
  }
  get key() {
    let { stack: t, siblings: u } = this;
    return b(0, t, u === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : b(0, this.stack, -2);
  }
  get node() {
    return b(0, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t } = this, u = b(0, t, -3);
    return Array.isArray(u) ? u : null;
  }
  get next() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index + 1];
  }
  get previous() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t, index: u } = this;
    return t !== null && u === t.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...__privateMethod(this, _Qt_instances, e_fn).call(this)];
  }
  getName() {
    let { stack: t } = this, { length: u } = t;
    return u > 1 ? b(0, t, -2) : null;
  }
  getValue() {
    return b(0, this.stack, -1);
  }
  getNode(t = 0) {
    let u = __privateMethod(this, _Qt_instances, t_fn).call(this, t);
    return u === -1 ? null : this.stack[u];
  }
  getParentNode(t = 0) {
    return this.getNode(t + 1);
  }
  call(t, ...u) {
    let { stack: r } = this, { length: o } = r, n = b(0, r, -1);
    for (let a of u) n = n == null ? void 0 : n[a], r.push(a, n);
    try {
      return t(this);
    } finally {
      r.length = o;
    }
  }
  callParent(t, u = 0) {
    let r = __privateMethod(this, _Qt_instances, t_fn).call(this, u + 1), o = this.stack.splice(r + 1);
    try {
      return t(this);
    } finally {
      this.stack.push(...o);
    }
  }
  each(t, ...u) {
    let { stack: r } = this, { length: o } = r, n = b(0, r, -1);
    for (let a of u) n = n[a], r.push(a, n);
    try {
      for (let a = 0; a < n.length; ++a) r.push(a, n[a]), t(this, a, n), r.length -= 2;
    } finally {
      r.length = o;
    }
  }
  map(t, ...u) {
    let r = [];
    return this.each((o, n, a) => {
      r[n] = t(o, n, a);
    }, ...u), r;
  }
  match(...t) {
    let u = this.stack.length - 1, r = null, o = this.stack[u--];
    for (let n of t) {
      if (o === void 0) return false;
      let a = null;
      if (typeof r == "number" && (a = r, r = this.stack[u--], o = this.stack[u--]), n && !n(o, r, a)) return false;
      r = this.stack[u--], o = this.stack[u--];
    }
    return true;
  }
  findAncestor(t) {
    for (let u of __privateMethod(this, _Qt_instances, e_fn).call(this)) if (t(u)) return u;
  }
  hasAncestor(t) {
    for (let u of __privateMethod(this, _Qt_instances, e_fn).call(this)) if (t(u)) return true;
    return false;
  }
}, _Qt_instances = new WeakSet(), t_fn = function(t) {
  let { stack: u } = this;
  for (let r = u.length - 1; r >= 0; r -= 2) if (!Array.isArray(u[r]) && --t < 0) return r;
  return -1;
}, e_fn = function* () {
  let { stack: t } = this;
  for (let u = t.length - 3; u >= 0; u -= 2) {
    let r = t[u];
    Array.isArray(r) || (yield r);
  }
}, _a);
var pr = Qt;
function ko(e) {
  return e !== null && typeof e == "object";
}
var ge = ko;
function ye(e) {
  return (t, u, r) => {
    let o = !!(r == null ? void 0 : r.backwards);
    if (u === false) return false;
    let { length: n } = t, a = u;
    for (; a >= 0 && a < n; ) {
      let s = t.charAt(a);
      if (e instanceof RegExp) {
        if (!e.test(s)) return a;
      } else if (!e.includes(s)) return a;
      o ? a-- : a++;
    }
    return a === -1 || a === n ? a : false;
  };
}
var Fr = ye(/\s/u);
var Y = ye(" 	");
var nt = ye(",; 	");
var ot = ye(/[^\n\r]/u);
var mr = (e) => e === `
` || e === "\r" || e === "\u2028" || e === "\u2029";
function vo(e, t, u) {
  let r = !!(u == null ? void 0 : u.backwards);
  if (t === false) return false;
  let o = e.charAt(t);
  if (r) {
    if (e.charAt(t - 1) === "\r" && o === `
`) return t - 2;
    if (mr(o)) return t - 1;
  } else {
    if (o === "\r" && e.charAt(t + 1) === `
`) return t + 2;
    if (mr(o)) return t + 1;
  }
  return t;
}
var K = vo;
function Ro(e, t, u = {}) {
  let r = Y(e, u.backwards ? t - 1 : t, u), o = K(e, r, u);
  return r !== o;
}
var z = Ro;
function Lo(e) {
  return Array.isArray(e) && e.length > 0;
}
var Er = Lo;
function* be(e, t) {
  let { getVisitorKeys: u, filter: r = () => true } = t, o = (n) => ge(n) && r(n);
  for (let n of u(e)) {
    let a = e[n];
    if (Array.isArray(a)) for (let s of a) o(s) && (yield s);
    else o(a) && (yield a);
  }
}
function* Cr(e, t) {
  let u = [e];
  for (let r = 0; r < u.length; r++) {
    let o = u[r];
    for (let n of be(o, t)) yield n, u.push(n);
  }
}
function hr(e, t) {
  return be(e, t).next().done;
}
function gr(e, t, u) {
  var _a3;
  let { cache: r } = u;
  if (r.has(e)) return r.get(e);
  let { filter: o } = u;
  if (!o) return [];
  let n, a = (((_a3 = u.getChildren) == null ? void 0 : _a3.call(u, e, u)) ?? [...be(e, { getVisitorKeys: u.getVisitorKeys })]).flatMap((D) => (n ?? (n = [e, ...t]), o(D, n) ? [D] : gr(D, n, u))), { locStart: s, locEnd: i } = u;
  return a.sort((D, f) => s(D) - s(f) || i(D) - i(f)), r.set(e, a), a;
}
var at = gr;
function Mo(e) {
  let t = e.type || e.kind || "(unknown type)", u = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
  return u.length > 20 && (u = u.slice(0, 19) + "…"), t + (u ? " " + u : "");
}
function Zt(e, t) {
  (e.comments ?? (e.comments = [])).push(t), t.printed = false, t.nodeDescription = Mo(e);
}
function fe(e, t) {
  t.leading = true, t.trailing = false, Zt(e, t);
}
function ue(e, t, u) {
  t.leading = false, t.trailing = false, u && (t.marker = u), Zt(e, t);
}
function le(e, t) {
  t.leading = false, t.trailing = true, Zt(e, t);
}
var uu = /* @__PURE__ */ new WeakMap();
function br(e, t, u, r, o = []) {
  let { locStart: n, locEnd: a } = u, s = n(t), i = a(t), D = at(e, o, { cache: uu, locStart: n, locEnd: a, getVisitorKeys: u.getVisitorKeys, filter: u.printer.canAttachComment, getChildren: u.printer.getCommentChildNodes }), f, l, d = 0, c = D.length;
  for (; d < c; ) {
    let p = d + c >> 1, F = D[p], C = n(F), y = a(F);
    if (C <= s && i <= y) return br(F, t, u, F, [F, ...o]);
    if (y <= s) {
      f = F, d = p + 1;
      continue;
    }
    if (i <= C) {
      l = F, c = p;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((r == null ? void 0 : r.type) === "TemplateLiteral") {
    let { quasis: p } = r, F = tu(p, t, u);
    f && tu(p, f, u) !== F && (f = null), l && tu(p, l, u) !== F && (l = null);
  }
  return { enclosingNode: r, precedingNode: f, followingNode: l };
}
var eu = () => false;
function Ar(e, t) {
  let { comments: u } = e;
  if (delete e.comments, !Er(u) || !t.printer.canAttachComment) return;
  let r = [], { printer: { features: { experimental_avoidAstMutation: o }, handleComments: n = {} }, originalText: a } = t, { ownLine: s = eu, endOfLine: i = eu, remaining: D = eu } = n, f = u.map((l, d) => ({ ...br(e, l, t), comment: l, text: a, options: t, ast: e, isLastComment: u.length - 1 === d }));
  for (let [l, d] of f.entries()) {
    let { comment: c, precedingNode: p, enclosingNode: F, followingNode: C, text: y, options: m, ast: h, isLastComment: E } = d, g;
    if (o ? g = [d] : (c.enclosingNode = F, c.precedingNode = p, c.followingNode = C, g = [c, y, m, h, E]), Yo(y, m, f, l)) c.placement = "ownLine", s(...g) || (C ? fe(C, c) : p ? le(p, c) : F ? ue(F, c) : ue(h, c));
    else if (jo(y, m, f, l)) c.placement = "endOfLine", i(...g) || (p ? le(p, c) : C ? fe(C, c) : F ? ue(F, c) : ue(h, c));
    else if (c.placement = "remaining", !D(...g)) if (p && C) {
      let A = r.length;
      A > 0 && r[A - 1].followingNode !== C && yr(r, m), r.push(d);
    } else p ? le(p, c) : C ? fe(C, c) : F ? ue(F, c) : ue(h, c);
  }
  if (yr(r, t), !o) for (let l of u) delete l.precedingNode, delete l.enclosingNode, delete l.followingNode;
}
var _r = (e) => !/[\S\n\u2028\u2029]/u.test(e);
function Yo(e, t, u, r) {
  let { comment: o, precedingNode: n } = u[r], { locStart: a, locEnd: s } = t, i = a(o);
  if (n) for (let D = r - 1; D >= 0; D--) {
    let { comment: f, precedingNode: l } = u[D];
    if (l !== n || !_r(e.slice(s(f), i))) break;
    i = a(f);
  }
  return z(e, i, { backwards: true });
}
function jo(e, t, u, r) {
  let { comment: o, followingNode: n } = u[r], { locStart: a, locEnd: s } = t, i = s(o);
  if (n) for (let D = r + 1; D < u.length; D++) {
    let { comment: f, followingNode: l } = u[D];
    if (l !== n || !_r(e.slice(i, a(f)))) break;
    i = s(f);
  }
  return z(e, i);
}
function yr(e, t) {
  var _a3, _b;
  let u = e.length;
  if (u === 0) return;
  let { precedingNode: r, followingNode: o } = e[0], n = t.locStart(o), a;
  for (a = u; a > 0; --a) {
    let { comment: s, precedingNode: i, followingNode: D } = e[a - 1];
    P(i, r), P(D, o);
    let f = t.originalText.slice(t.locEnd(s), n);
    if (((_b = (_a3 = t.printer).isGap) == null ? void 0 : _b.call(_a3, f, t)) ?? /^[\s(]*$/u.test(f)) n = t.locStart(s);
    else break;
  }
  for (let [s, { comment: i }] of e.entries()) s < a ? le(r, i) : fe(o, i);
  for (let s of [r, o]) s.comments && s.comments.length > 1 && s.comments.sort((i, D) => t.locStart(i) - t.locStart(D));
  e.length = 0;
}
function tu(e, t, u) {
  let r = u.locStart(t) - 1;
  for (let o = 1; o < e.length; ++o) if (r < u.locStart(e[o])) return o - 1;
  return 0;
}
function Uo(e, t) {
  let u = t - 1;
  u = Y(e, u, { backwards: true }), u = K(e, u, { backwards: true }), u = Y(e, u, { backwards: true });
  let r = K(e, u, { backwards: true });
  return u !== r;
}
var Le = Uo;
function xr(e, t) {
  let u = e.node;
  return u.printed = true, t.printer.printComment(e, t);
}
function Wo(e, t) {
  var _a3;
  let u = e.node, r = [xr(e, t)], { printer: o, originalText: n, locStart: a, locEnd: s } = t;
  if ((_a3 = o.isBlockComment) == null ? void 0 : _a3.call(o, u)) {
    let f = z(n, s(u)) ? z(n, a(u), { backwards: true }) ? V : ut : " ";
    r.push(f);
  } else r.push(V);
  let D = K(n, Y(n, s(u)));
  return D !== false && z(n, D) && r.push(V), r;
}
function $o(e, t, u) {
  var _a3;
  let r = e.node, o = xr(e, t), { printer: n, originalText: a, locStart: s } = t, i = (_a3 = n.isBlockComment) == null ? void 0 : _a3.call(n, r);
  if ((u == null ? void 0 : u.hasLineSuffix) && !(u == null ? void 0 : u.isBlock) || z(a, s(r), { backwards: true })) {
    let D = Le(a, s(r));
    return { doc: ve([V, D ? V : "", o]), isBlock: i, hasLineSuffix: true };
  }
  return !i || (u == null ? void 0 : u.hasLineSuffix) ? { doc: [ve([" ", o]), ce], isBlock: i, hasLineSuffix: true } : { doc: [" ", o], isBlock: i, hasLineSuffix: false };
}
function Vo(e, t) {
  let u = e.node;
  if (!u) return {};
  let r = t[Symbol.for("printedComments")];
  if ((u.comments || []).filter((i) => !r.has(i)).length === 0) return { leading: "", trailing: "" };
  let n = [], a = [], s;
  return e.each(() => {
    let i = e.node;
    if (r == null ? void 0 : r.has(i)) return;
    let { leading: D, trailing: f } = i;
    D ? n.push(Wo(e, t)) : f && (s = $o(e, t, s), a.push(s.doc));
  }, "comments"), { leading: n, trailing: a };
}
function Br(e, t, u) {
  let { leading: r, trailing: o } = Vo(e, u);
  return !r && !o ? t : Ee(t, (n) => [r, n, o]);
}
function Tr(e) {
  let { [Symbol.for("comments")]: t, [Symbol.for("printedComments")]: u } = e;
  for (let r of t) {
    if (!r.printed && !u.has(r)) throw new Error('Comment "' + r.value.trim() + '" was not printed. Please report this error!');
    delete r.printed;
  }
}
var Nr = () => P;
var Me = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ConfigError");
  }
};
var Ye = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UndefinedParserError");
  }
};
var Sr = { checkIgnorePragma: { category: "Special", type: "boolean", default: false, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: "Other" }, cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }, { value: "mjml", description: "MJML" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function it({ plugins: e = [], showDeprecated: t = false } = {}) {
  let u = e.flatMap((o) => o.languages ?? []), r = [];
  for (let o of Go(Object.assign({}, ...e.map(({ options: n }) => n), Sr))) !t && o.deprecated || (Array.isArray(o.choices) && (t || (o.choices = o.choices.filter((n) => !n.deprecated)), o.name === "parser" && (o.choices = [...o.choices, ...Ko(o.choices, u, e)])), o.pluginDefaults = Object.fromEntries(e.filter((n) => {
    var _a3;
    return ((_a3 = n.defaultOptions) == null ? void 0 : _a3[o.name]) !== void 0;
  }).map((n) => [n.name, n.defaultOptions[o.name]])), r.push(o));
  return { languages: u, options: r };
}
function* Ko(e, t, u) {
  let r = new Set(e.map((o) => o.value));
  for (let o of t) if (o.parsers) {
    for (let n of o.parsers) if (!r.has(n)) {
      r.add(n);
      let a = u.find((i) => i.parsers && Object.prototype.hasOwnProperty.call(i.parsers, n)), s = o.name;
      (a == null ? void 0 : a.name) && (s += ` (plugin: ${a.name})`), yield { value: n, description: s };
    }
  }
}
function Go(e) {
  let t = [];
  for (let [u, r] of Object.entries(e)) {
    let o = { name: u, ...r };
    Array.isArray(o.default) && (o.default = b(0, o.default, -1).value), t.push(o);
  }
  return t;
}
var zo = Array.prototype.toReversed ?? function() {
  return [...this].reverse();
};
var Jo = X("toReversed", function() {
  if (Array.isArray(this)) return zo;
});
var wr = Jo;
function Ho() {
  var _a3, _b, _c, _d, _e2, _f;
  let e = globalThis, t = (_b = (_a3 = e.Deno) == null ? void 0 : _a3.build) == null ? void 0 : _b.os;
  return typeof t == "string" ? t === "windows" : ((_d = (_c = e.navigator) == null ? void 0 : _c.platform) == null ? void 0 : _d.startsWith("Win")) ?? ((_f = (_e2 = e.process) == null ? void 0 : _e2.platform) == null ? void 0 : _f.startsWith("win")) ?? false;
}
var Xo = Ho();
function Or(e) {
  if (e = e instanceof URL ? e : new URL(e), e.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${e.protocol}"`);
  return e;
}
function qo(e) {
  return e = Or(e), decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function Qo(e) {
  e = Or(e);
  let t = decodeURIComponent(e.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return e.hostname !== "" && (t = `\\\\${e.hostname}${t}`), t;
}
function ru(e) {
  return Xo ? Qo(e) : qo(e);
}
var Pr = (e) => String(e).split(/[/\\]/u).pop();
var Ir = (e) => String(e).startsWith("file:");
function kr(e, t) {
  if (!t) return;
  let u = Pr(t).toLowerCase();
  return e.find(({ filenames: r }) => r == null ? void 0 : r.some((o) => o.toLowerCase() === u)) ?? e.find(({ extensions: r }) => r == null ? void 0 : r.some((o) => u.endsWith(o)));
}
function Zo(e, t) {
  if (t) return e.find(({ name: u }) => u.toLowerCase() === t) ?? e.find(({ aliases: u }) => u == null ? void 0 : u.includes(t)) ?? e.find(({ extensions: u }) => u == null ? void 0 : u.includes(`.${t}`));
}
var ea = void 0;
function vr(e, t) {
  if (t) {
    if (Ir(t)) try {
      t = ru(t);
    } catch {
      return;
    }
    if (typeof t == "string") return e.find(({ isSupported: u }) => u == null ? void 0 : u({ filepath: t }));
  }
}
function ta(e, t) {
  var _a3;
  let u = wr(0, e.plugins).flatMap((o) => o.languages ?? []);
  return (_a3 = Zo(u, t.language) ?? kr(u, t.physicalFile) ?? kr(u, t.file) ?? vr(u, t.physicalFile) ?? vr(u, t.file) ?? (ea == null ? void 0 : ea(u, t.physicalFile))) == null ? void 0 : _a3.parsers[0];
}
var st = ta;
var ie = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
  if (e === null || typeof e != "object") return JSON.stringify(e);
  if (Array.isArray(e)) return `[${e.map((u) => ie.value(u)).join(", ")}]`;
  let t = Object.keys(e);
  return t.length === 0 ? "{}" : `{ ${t.map((u) => `${ie.key(u)}: ${ie.value(e[u])}`).join(", ")} }`;
}, pair: ({ key: e, value: t }) => ie.value({ [e]: t }) };
var nu = new Proxy(String, { get: () => nu });
var $ = nu;
var ou = () => nu;
var Rr = (e, t, { descriptor: u }) => {
  let r = [`${$.yellow(typeof e == "string" ? u.key(e) : u.pair(e))} is deprecated`];
  return t && r.push(`we now treat it as ${$.blue(typeof t == "string" ? u.key(t) : u.pair(t))}`), r.join("; ") + ".";
};
var Dt = Symbol.for("vnopts.VALUE_NOT_EXIST");
var Ae = Symbol.for("vnopts.VALUE_UNCHANGED");
var Lr = " ".repeat(2);
var Yr = (e, t, u) => {
  let { text: r, list: o } = u.normalizeExpectedResult(u.schemas[e].expected(u)), n = [];
  return r && n.push(Mr(e, t, r, u.descriptor)), o && n.push([Mr(e, t, o.title, u.descriptor)].concat(o.values.map((a) => jr(a, u.loggerPrintWidth))).join(`
`)), Ur(n, u.loggerPrintWidth);
};
function Mr(e, t, u, r) {
  return [`Invalid ${$.red(r.key(e))} value.`, `Expected ${$.blue(u)},`, `but received ${t === Dt ? $.gray("nothing") : $.red(r.value(t))}.`].join(" ");
}
function jr({ text: e, list: t }, u) {
  let r = [];
  return e && r.push(`- ${$.blue(e)}`), t && r.push([`- ${$.blue(t.title)}:`].concat(t.values.map((o) => jr(o, u - Lr.length).replace(/^|\n/g, `$&${Lr}`))).join(`
`)), Ur(r, u);
}
function Ur(e, t) {
  if (e.length === 1) return e[0];
  let [u, r] = e, [o, n] = e.map((a) => a.split(`
`, 1)[0].length);
  return o > t && o > n ? r : u;
}
var _e = [];
var au = [];
function ct(e, t, u) {
  if (e === t) return 0;
  let r = u == null ? void 0 : u.maxDistance, o = e;
  e.length > t.length && (e = t, t = o);
  let n = e.length, a = t.length;
  for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-a); ) n--, a--;
  let s = 0;
  for (; s < n && e.charCodeAt(s) === t.charCodeAt(s); ) s++;
  if (n -= s, a -= s, r !== void 0 && a - n > r) return r;
  if (n === 0) return r !== void 0 && a > r ? r : a;
  let i, D, f, l, d = 0, c = 0;
  for (; d < n; ) au[d] = e.charCodeAt(s + d), _e[d] = ++d;
  for (; c < a; ) {
    for (i = t.charCodeAt(s + c), f = c++, D = c, d = 0; d < n; d++) l = i === au[d] ? f : f + 1, f = _e[d], D = _e[d] = f > D ? l > D ? D + 1 : l : l > f ? f + 1 : l;
    if (r !== void 0) {
      let p = D;
      for (d = 0; d < n; d++) _e[d] < p && (p = _e[d]);
      if (p > r) return r;
    }
  }
  return _e.length = n, au.length = n, r !== void 0 && D > r ? r : D;
}
function Wr(e, t, u) {
  if (!Array.isArray(t) || t.length === 0) return;
  let r = u == null ? void 0 : u.maxDistance, o = e.length;
  for (let i of t) if (i === e) return i;
  if (r === 0) return;
  let n, a = Number.POSITIVE_INFINITY, s = /* @__PURE__ */ new Set();
  for (let i of t) {
    if (s.has(i)) continue;
    s.add(i);
    let D = Math.abs(i.length - o);
    if (D >= a || r !== void 0 && D > r) continue;
    let f = Number.isFinite(a) ? r === void 0 ? a : Math.min(a, r) : r, l = f === void 0 ? ct(e, i) : ct(e, i, { maxDistance: f });
    if (r !== void 0 && l > r) continue;
    let d = l;
    if (f !== void 0 && l === f && f === r && (d = ct(e, i)), d < a && (a = d, n = i, a === 0)) break;
  }
  if (!(r !== void 0 && a > r)) return n;
}
var ft = (e, t, { descriptor: u, logger: r, schemas: o }) => {
  let n = [`Ignored unknown option ${$.yellow(u.pair({ key: e, value: t }))}.`], a = Wr(e, Object.keys(o), { maxDistance: 3 });
  a && n.push(`Did you mean ${$.blue(u.key(a))}?`), r.warn(n.join(" "));
};
var ua = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function ra(e, t) {
  let u = new e(t), r = Object.create(u);
  for (let o of ua) o in t && (r[o] = na(t[o], u, S.prototype[o].length));
  return r;
}
var S = class {
  static create(t) {
    return ra(this, t);
  }
  constructor(t) {
    this.name = t.name;
  }
  default(t) {
  }
  expected(t) {
    return "nothing";
  }
  validate(t, u) {
    return false;
  }
  deprecated(t, u) {
    return false;
  }
  forward(t, u) {
  }
  redirect(t, u) {
  }
  overlap(t, u, r) {
    return t;
  }
  preprocess(t, u) {
    return t;
  }
  postprocess(t, u) {
    return Ae;
  }
};
function na(e, t, u) {
  return typeof e == "function" ? (...r) => e(...r.slice(0, u - 1), t, ...r.slice(u - 1)) : () => e;
}
var lt = class extends S {
  constructor(t) {
    super(t), this._sourceName = t.sourceName;
  }
  expected(t) {
    return t.schemas[this._sourceName].expected(t);
  }
  validate(t, u) {
    return u.schemas[this._sourceName].validate(t, u);
  }
  redirect(t, u) {
    return this._sourceName;
  }
};
var dt = class extends S {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var pt = class extends S {
  constructor({ valueSchema: t, name: u = t.name, ...r }) {
    super({ ...r, name: u }), this._valueSchema = t;
  }
  expected(t) {
    let { text: u, list: r } = t.normalizeExpectedResult(this._valueSchema.expected(t));
    return { text: u && `an array of ${u}`, list: r && { title: "an array of the following values", values: [{ list: r }] } };
  }
  validate(t, u) {
    if (!Array.isArray(t)) return false;
    let r = [];
    for (let o of t) {
      let n = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);
      n !== true && r.push(n.value);
    }
    return r.length === 0 ? true : { value: r };
  }
  deprecated(t, u) {
    let r = [];
    for (let o of t) {
      let n = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);
      n !== false && r.push(...n.map(({ value: a }) => ({ value: [a] })));
    }
    return r;
  }
  forward(t, u) {
    let r = [];
    for (let o of t) {
      let n = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);
      r.push(...n.map($r));
    }
    return r;
  }
  redirect(t, u) {
    let r = [], o = [];
    for (let n of t) {
      let a = u.normalizeRedirectResult(this._valueSchema.redirect(n, u), n);
      "remain" in a && r.push(a.remain), o.push(...a.redirect.map($r));
    }
    return r.length === 0 ? { redirect: o } : { redirect: o, remain: r };
  }
  overlap(t, u) {
    return t.concat(u);
  }
};
function $r({ from: e, to: t }) {
  return { from: [e], to: t };
}
var Ft = class extends S {
  expected() {
    return "true or false";
  }
  validate(t) {
    return typeof t == "boolean";
  }
};
function Kr(e, t) {
  let u = /* @__PURE__ */ Object.create(null);
  for (let r of e) {
    let o = r[t];
    if (u[o]) throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);
    u[o] = r;
  }
  return u;
}
function Gr(e, t) {
  let u = /* @__PURE__ */ new Map();
  for (let r of e) {
    let o = r[t];
    if (u.has(o)) throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);
    u.set(o, r);
  }
  return u;
}
function zr() {
  let e = /* @__PURE__ */ Object.create(null);
  return (t) => {
    let u = JSON.stringify(t);
    return e[u] ? true : (e[u] = true, false);
  };
}
function Jr(e, t) {
  let u = [], r = [];
  for (let o of e) t(o) ? u.push(o) : r.push(o);
  return [u, r];
}
function Hr(e) {
  return e === Math.floor(e);
}
function Xr(e, t) {
  if (e === t) return 0;
  let u = typeof e, r = typeof t, o = ["undefined", "object", "boolean", "number", "string"];
  return u !== r ? o.indexOf(u) - o.indexOf(r) : u !== "string" ? Number(e) - Number(t) : e.localeCompare(t);
}
function qr(e) {
  return (...t) => {
    let u = e(...t);
    return typeof u == "string" ? new Error(u) : u;
  };
}
function iu(e) {
  return e === void 0 ? {} : e;
}
function su(e) {
  if (typeof e == "string") return { text: e };
  let { text: t, list: u } = e;
  return oa((t || u) !== void 0, "Unexpected `expected` result, there should be at least one field."), u ? { text: t, list: { title: u.title, values: u.values.map(su) } } : { text: t };
}
function Du(e, t) {
  return e === true ? true : e === false ? { value: t } : e;
}
function cu(e, t, u = false) {
  return e === false ? false : e === true ? u ? true : [{ value: t }] : "value" in e ? [e] : e.length === 0 ? false : e;
}
function Vr(e, t) {
  return typeof e == "string" || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
}
function mt(e, t) {
  return e === void 0 ? [] : Array.isArray(e) ? e.map((u) => Vr(u, t)) : [Vr(e, t)];
}
function fu(e, t) {
  let u = mt(typeof e == "object" && "redirect" in e ? e.redirect : e, t);
  return u.length === 0 ? { remain: t, redirect: u } : typeof e == "object" && "remain" in e ? { remain: e.remain, redirect: u } : { redirect: u };
}
function oa(e, t) {
  if (!e) throw new Error(t);
}
var Et = class extends S {
  constructor(t) {
    super(t), this._choices = Gr(t.choices.map((u) => u && typeof u == "object" ? u : { value: u }), "value");
  }
  expected({ descriptor: t }) {
    let u = Array.from(this._choices.keys()).map((a) => this._choices.get(a)).filter(({ hidden: a }) => !a).map((a) => a.value).sort(Xr).map(t.value), r = u.slice(0, -2), o = u.slice(-2);
    return { text: r.concat(o.join(" or ")).join(", "), list: { title: "one of the following values", values: u } };
  }
  validate(t) {
    return this._choices.has(t);
  }
  deprecated(t) {
    let u = this._choices.get(t);
    return u && u.deprecated ? { value: t } : false;
  }
  forward(t) {
    let u = this._choices.get(t);
    return u ? u.forward : void 0;
  }
  redirect(t) {
    let u = this._choices.get(t);
    return u ? u.redirect : void 0;
  }
};
var Ct = class extends S {
  expected() {
    return "a number";
  }
  validate(t, u) {
    return typeof t == "number";
  }
};
var ht = class extends Ct {
  expected() {
    return "an integer";
  }
  validate(t, u) {
    return u.normalizeValidateResult(super.validate(t, u), t) === true && Hr(t);
  }
};
var je = class extends S {
  expected() {
    return "a string";
  }
  validate(t) {
    return typeof t == "string";
  }
};
var Qr = ie;
var Zr = ft;
var en = Yr;
var tn = Rr;
var gt = class {
  constructor(t, u) {
    let { logger: r = console, loggerPrintWidth: o = 80, descriptor: n = Qr, unknown: a = Zr, invalid: s = en, deprecated: i = tn, missing: D = () => false, required: f = () => false, preprocess: l = (c) => c, postprocess: d = () => Ae } = u || {};
    this._utils = { descriptor: n, logger: r || { warn: () => {
    } }, loggerPrintWidth: o, schemas: Kr(t, "name"), normalizeDefaultResult: iu, normalizeExpectedResult: su, normalizeDeprecatedResult: cu, normalizeForwardResult: mt, normalizeRedirectResult: fu, normalizeValidateResult: Du }, this._unknownHandler = a, this._invalidHandler = qr(s), this._deprecatedHandler = i, this._identifyMissing = (c, p) => !(c in p) || D(c, p), this._identifyRequired = f, this._preprocess = l, this._postprocess = d, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = zr();
  }
  normalize(t) {
    let u = {}, o = [this._preprocess(t, this._utils)], n = () => {
      for (; o.length !== 0; ) {
        let a = o.shift(), s = this._applyNormalization(a, u);
        o.push(...s);
      }
    };
    n();
    for (let a of Object.keys(this._utils.schemas)) {
      let s = this._utils.schemas[a];
      if (!(a in u)) {
        let i = iu(s.default(this._utils));
        "value" in i && o.push({ [a]: i.value });
      }
    }
    n();
    for (let a of Object.keys(this._utils.schemas)) {
      if (!(a in u)) continue;
      let s = this._utils.schemas[a], i = u[a], D = s.postprocess(i, this._utils);
      D !== Ae && (this._applyValidation(D, a, s), u[a] = D);
    }
    return this._applyPostprocess(u), this._applyRequiredCheck(u), u;
  }
  _applyNormalization(t, u) {
    let r = [], { knownKeys: o, unknownKeys: n } = this._partitionOptionKeys(t);
    for (let a of o) {
      let s = this._utils.schemas[a], i = s.preprocess(t[a], this._utils);
      this._applyValidation(i, a, s);
      let D = ({ from: c, to: p }) => {
        r.push(typeof p == "string" ? { [p]: c } : { [p.key]: p.value });
      }, f = ({ value: c, redirectTo: p }) => {
        let F = cu(s.deprecated(c, this._utils), i, true);
        if (F !== false) if (F === true) this._hasDeprecationWarned(a) || this._utils.logger.warn(this._deprecatedHandler(a, p, this._utils));
        else for (let { value: C } of F) {
          let y = { key: a, value: C };
          if (!this._hasDeprecationWarned(y)) {
            let m = typeof p == "string" ? { key: p, value: C } : p;
            this._utils.logger.warn(this._deprecatedHandler(y, m, this._utils));
          }
        }
      };
      mt(s.forward(i, this._utils), i).forEach(D);
      let d = fu(s.redirect(i, this._utils), i);
      if (d.redirect.forEach(D), "remain" in d) {
        let c = d.remain;
        u[a] = a in u ? s.overlap(u[a], c, this._utils) : c, f({ value: c });
      }
      for (let { from: c, to: p } of d.redirect) f({ value: c, redirectTo: p });
    }
    for (let a of n) {
      let s = t[a];
      this._applyUnknownHandler(a, s, u, (i, D) => {
        r.push({ [i]: D });
      });
    }
    return r;
  }
  _applyRequiredCheck(t) {
    for (let u of Object.keys(this._utils.schemas)) if (this._identifyMissing(u, t) && this._identifyRequired(u)) throw this._invalidHandler(u, Dt, this._utils);
  }
  _partitionOptionKeys(t) {
    let [u, r] = Jr(Object.keys(t).filter((o) => !this._identifyMissing(o, t)), (o) => o in this._utils.schemas);
    return { knownKeys: u, unknownKeys: r };
  }
  _applyValidation(t, u, r) {
    let o = Du(r.validate(t, this._utils), t);
    if (o !== true) throw this._invalidHandler(u, o.value, this._utils);
  }
  _applyUnknownHandler(t, u, r, o) {
    let n = this._unknownHandler(t, u, this._utils);
    if (n) for (let a of Object.keys(n)) {
      if (this._identifyMissing(a, n)) continue;
      let s = n[a];
      a in this._utils.schemas ? o(a, s) : r[a] = s;
    }
  }
  _applyPostprocess(t) {
    let u = this._postprocess(t, this._utils);
    if (u !== Ae) {
      if (u.delete) for (let r of u.delete) delete t[r];
      if (u.override) {
        let { knownKeys: r, unknownKeys: o } = this._partitionOptionKeys(u.override);
        for (let n of r) {
          let a = u.override[n];
          this._applyValidation(a, n, this._utils.schemas[n]), t[n] = a;
        }
        for (let n of o) {
          let a = u.override[n];
          this._applyUnknownHandler(n, a, t, (s, i) => {
            let D = this._utils.schemas[s];
            this._applyValidation(i, s, D), t[s] = i;
          });
        }
      }
    }
  }
};
var lu;
function ia(e, t, { logger: u = false, isCLI: r = false, passThrough: o = false, FlagSchema: n, descriptor: a } = {}) {
  if (r) {
    if (!n) throw new Error("'FlagSchema' option is required.");
    if (!a) throw new Error("'descriptor' option is required.");
  } else a = ie;
  let s = o ? Array.isArray(o) ? (d, c) => o.includes(d) ? { [d]: c } : void 0 : (d, c) => ({ [d]: c }) : (d, c, p) => {
    let { _: F, ...C } = p.schemas;
    return ft(d, c, { ...p, schemas: C });
  }, i = sa(t, { isCLI: r, FlagSchema: n }), D = new gt(i, { logger: u, unknown: s, descriptor: a }), f = u !== false;
  f && lu && (D._hasDeprecationWarned = lu);
  let l = D.normalize(e);
  return f && (lu = D._hasDeprecationWarned), l;
}
function sa(e, { isCLI: t, FlagSchema: u }) {
  let r = [];
  t && r.push(dt.create({ name: "_" }));
  for (let o of e) r.push(Da(o, { isCLI: t, optionInfos: e, FlagSchema: u })), o.alias && t && r.push(lt.create({ name: o.alias, sourceName: o.name }));
  return r;
}
function Da(e, { isCLI: t, optionInfos: u, FlagSchema: r }) {
  let { name: o } = e, n = { name: o }, a, s = {};
  switch (e.type) {
    case "int":
      a = ht, t && (n.preprocess = Number);
      break;
    case "string":
      a = je;
      break;
    case "choice":
      a = Et, n.choices = e.choices.map((i) => (i == null ? void 0 : i.redirect) ? { ...i, redirect: { to: { key: e.name, value: i.redirect } } } : i);
      break;
    case "boolean":
      a = Ft;
      break;
    case "flag":
      a = r, n.flags = u.flatMap((i) => [i.alias, i.description && i.name, i.oppositeDescription && `no-${i.name}`].filter(Boolean));
      break;
    case "path":
      a = je;
      break;
    default:
      throw new Error(`Unexpected type ${e.type}`);
  }
  if (e.exception ? n.validate = (i, D, f) => e.exception(i) || D.validate(i, f) : n.validate = (i, D, f) => i === void 0 || D.validate(i, f), e.redirect && (s.redirect = (i) => i ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (s.deprecated = true), t && !e.array) {
    let i = n.preprocess || ((D) => D);
    n.preprocess = (D, f, l) => f.preprocess(i(Array.isArray(D) ? b(0, D, -1) : D), l);
  }
  return e.array ? pt.create({ ...t ? { preprocess: (i) => Array.isArray(i) ? i : [i] } : {}, ...s, valueSchema: a.create(n) }) : a.create({ ...n, ...s });
}
var un = ia;
var ca = Array.prototype.findLast ?? function(e) {
  for (let t = this.length - 1; t >= 0; t--) {
    let u = this[t];
    if (e(u, t, this)) return u;
  }
};
var fa = X("findLast", function() {
  if (Array.isArray(this)) return ca;
});
var du = fa;
var rn = Symbol.for("PRETTIER_IS_FRONT_MATTER");
var pu = [];
function la(e) {
  return !!(e == null ? void 0 : e[rn]);
}
var de = la;
var nn = /* @__PURE__ */ new Set(["yaml", "toml"]);
var Ue = ({ node: e }) => de(e) && nn.has(e.language);
async function Fu(e, t, u, r) {
  let { node: o } = u, { language: n } = o;
  if (!nn.has(n)) return;
  let a = o.value.trim(), s;
  if (a) {
    let i = n === "yaml" ? n : st(r, { language: n });
    if (!i) return;
    s = a ? await e(a, { parser: i }) : "";
  } else s = a;
  return et([o.startDelimiter, o.explicitLanguage ?? "", V, s, s ? V : "", o.endDelimiter]);
}
function da(e, t) {
  return Ue({ node: e }) && (delete t.end, delete t.raw, delete t.value), t;
}
var mu = da;
function pa({ node: e }) {
  return e.raw;
}
var Eu = pa;
var on = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
var Fa = (e) => Object.keys(e).filter((t) => !on.has(t));
function ma(e, t) {
  let u = e ? (r) => e(r, on) : Fa;
  return t ? new Proxy(u, { apply: (r, o, n) => de(n[0]) ? pu : Reflect.apply(r, o, n) }) : u;
}
var Cu = ma;
function gu(e, t) {
  if (!t) throw new Error("parserName is required.");
  let u = du(0, e, (o) => o.parsers && Object.prototype.hasOwnProperty.call(o.parsers, t));
  if (u) return u;
  let r = `Couldn't resolve parser "${t}".`;
  throw r += " Plugins must be explicitly added to the standalone bundle.", new Me(r);
}
function an(e, t) {
  if (!t) throw new Error("astFormat is required.");
  let u = du(0, e, (o) => o.printers && Object.prototype.hasOwnProperty.call(o.printers, t));
  if (u) return u;
  let r = `Couldn't find plugin for AST format "${t}".`;
  throw r += " Plugins must be explicitly added to the standalone bundle.", new Me(r);
}
function We({ plugins: e, parser: t }) {
  let u = gu(e, t);
  return yu(u, t);
}
function yu(e, t) {
  let u = e.parsers[t];
  return typeof u == "function" ? u() : u;
}
async function sn(e, t) {
  let u = e.printers[t], r = typeof u == "function" ? await u() : u;
  return Ea(r);
}
var hu = /* @__PURE__ */ new WeakMap();
var q0 = Symbol("PRINTER_NORMALIZED_MARK");
function Ea(e) {
  if (hu.has(e)) return hu.get(e);
  let { features: t, getVisitorKeys: u, embed: r, massageAstNode: o, print: n, ...a } = e;
  t = ya(t);
  let s = t.experimental_frontMatterSupport;
  u = Cu(u, s.massageAstNode || s.embed || s.print);
  let i = o;
  o && s.massageAstNode && (i = new Proxy(o, { apply(d, c, p) {
    return mu(...p), Reflect.apply(d, c, p);
  } }));
  let D = r;
  if (r) {
    let d;
    D = new Proxy(r, { get(c, p, F) {
      return p === "getVisitorKeys" ? (d ?? (d = r.getVisitorKeys ? Cu(r.getVisitorKeys, s.massageAstNode || s.embed) : u), d) : Reflect.get(c, p, F);
    }, apply: (c, p, F) => s.embed && Ue(...F) ? Fu : Reflect.apply(c, p, F) });
  }
  let f = n;
  s.print && (f = new Proxy(n, { apply(d, c, p) {
    let [F] = p;
    return de(F.node) ? Eu(F) : Reflect.apply(d, c, p);
  } }));
  let l = { features: t, getVisitorKeys: u, embed: D, massageAstNode: i, print: f, ...a };
  return hu.set(e, l), l;
}
var Ca = ["clean", "embed", "print"];
var ha = Object.fromEntries(Ca.map((e) => [e, false]));
function ga(e) {
  return { ...ha, ...e };
}
function ya(e) {
  return { experimental_avoidAstMutation: false, ...e, experimental_frontMatterSupport: ga(e == null ? void 0 : e.experimental_frontMatterSupport) };
}
var Dn = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null, getVisitorKeys: null };
async function ba(e, t = {}) {
  var _a3;
  let u = { ...e };
  if (!u.parser) if (u.filepath) {
    if (u.parser = st(u, { physicalFile: u.filepath }), !u.parser) throw new Ye(`No parser could be inferred for file "${u.filepath}".`);
  } else throw new Ye("No parser and no file path given, couldn't infer a parser.");
  let r = it({ plugins: e.plugins, showDeprecated: true }).options, o = { ...Dn, ...Object.fromEntries(r.filter((l) => l.default !== void 0).map((l) => [l.name, l.default])) }, n = gu(u.plugins, u.parser), a = await yu(n, u.parser);
  u.astFormat = a.astFormat, u.locEnd = a.locEnd, u.locStart = a.locStart;
  let s = ((_a3 = n.printers) == null ? void 0 : _a3[a.astFormat]) ? n : an(u.plugins, a.astFormat), i = await sn(s, a.astFormat);
  u.printer = i, u.getVisitorKeys = i.getVisitorKeys;
  let D = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, l]) => l !== void 0)) : {}, f = { ...o, ...D };
  for (let [l, d] of Object.entries(f)) (u[l] === null || u[l] === void 0) && (u[l] = d);
  return u.parser === "json" && (u.trailingComma = "none"), un(u, r, { passThrough: Object.keys(Dn), ...t });
}
var se = ba;
var pf = ao(dn(), 1);
var Au = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-࢏ࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚ౜ౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ೜-ೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-Ƛ꟱-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var pn = "·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-᫝᫠-᫫ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var af = new RegExp("[" + Au + "]");
var sf = new RegExp("[" + Au + pn + "]");
Au = pn = null;
var _u = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] };
var Df = new Set(_u.keyword);
var cf = new Set(_u.strict);
var ff = new Set(_u.strictBind);
var It = (e, t) => (u) => e(t(u));
function mn(e) {
  return { keyword: e.cyan, capitalized: e.yellow, jsxIdentifier: e.yellow, punctuator: e.yellow, number: e.magenta, string: e.green, regex: e.magenta, comment: e.gray, invalid: It(It(e.white, e.bgRed), e.bold), gutter: e.gray, marker: It(e.red, e.bold), message: It(e.red, e.bold), reset: e.reset };
}
var hf = mn(ou(true));
var gf = mn(ou(false));
function _a2() {
  return new Proxy({}, { get: () => (e) => e });
}
var Fn = /\r\n|[\n\r\u2028\u2029]/;
function xa(e, t, u) {
  let r = Object.assign({ column: 0, line: -1 }, e.start), o = Object.assign({}, r, e.end), { linesAbove: n = 2, linesBelow: a = 3 } = u || {}, s = r.line, i = r.column, D = o.line, f = o.column, l = Math.max(s - (n + 1), 0), d = Math.min(t.length, D + a);
  s === -1 && (l = 0), D === -1 && (d = t.length);
  let c = D - s, p = {};
  if (c) for (let F = 0; F <= c; F++) {
    let C = F + s;
    if (!i) p[C] = true;
    else if (F === 0) {
      let y = t[C - 1].length;
      p[C] = [i, y - i + 1];
    } else if (F === c) p[C] = [0, f];
    else {
      let y = t[C - F].length;
      p[C] = [0, y];
    }
  }
  else i === f ? i ? p[s] = [i, 0] : p[s] = true : p[s] = [i, f - i];
  return { start: l, end: d, markerLines: p };
}
function En(e, t, u = {}) {
  let o = _a2(false), n = e.split(Fn), { start: a, end: s, markerLines: i } = xa(t, n, u), D = t.start && typeof t.start.column == "number", f = String(s).length, d = e.split(Fn, s).slice(a, s).map((c, p) => {
    let F = a + 1 + p, y = ` ${` ${F}`.slice(-f)} |`, m = i[F], h = !i[F + 1];
    if (m) {
      let E = "";
      if (Array.isArray(m)) {
        let g = c.slice(0, Math.max(m[0] - 1, 0)).replace(/[^\t]/g, " "), A = m[1] || 1;
        E = [`
 `, o.gutter(y.replace(/\d/g, " ")), " ", g, o.marker("^").repeat(A)].join(""), h && u.message && (E += " " + o.message(u.message));
      }
      return [o.marker(">"), o.gutter(y), c.length > 0 ? ` ${c}` : "", E].join("");
    } else return ` ${o.gutter(y)}${c.length > 0 ? ` ${c}` : ""}`;
  }).join(`
`);
  return u.message && !D && (d = `${" ".repeat(f + 1)}${u.message}
${d}`), d;
}
async function Ba(e, t) {
  let u = await We(t), r = u.preprocess ? await u.preprocess(e, t) : e;
  t.originalText = r;
  let o;
  try {
    o = await u.parse(r, t, t);
  } catch (n) {
    Ta(n, e);
  }
  return { text: r, ast: o };
}
function Ta(e, t) {
  let { loc: u } = e;
  if (u) {
    let r = En(t, u, { highlightCode: true });
    throw e.message += `
` + r, e.codeFrame = r, e;
  }
  throw e;
}
var Fe = Ba;
async function Cn(e, t, u, r, o) {
  if (u.embeddedLanguageFormatting !== "auto") return;
  let { printer: n } = u, { embed: a } = n;
  if (!a) return;
  if (a.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let { hasPrettierIgnore: s } = n, { getVisitorKeys: i } = a, D = [];
  d();
  let f = e.stack;
  for (let { print: c, node: p, pathStack: F } of D) try {
    e.stack = F;
    let C = await c(l, t, e, u);
    C && o.set(p, C);
  } catch (C) {
    if (globalThis.PRETTIER_DEBUG) throw C;
  }
  e.stack = f;
  function l(c, p) {
    return Na(c, p, u, r);
  }
  function d() {
    let { node: c } = e;
    if (c === null || typeof c != "object" || (s == null ? void 0 : s(e))) return;
    for (let F of i(c)) Array.isArray(c[F]) ? e.each(d, F) : e.call(d, F);
    let p = a(e, u);
    if (p) {
      if (typeof p == "function") {
        D.push({ print: p, node: c, pathStack: [...e.stack] });
        return;
      }
      o.set(c, p);
    }
  }
}
async function Na(e, t, u, r) {
  let o = await se({ ...u, ...t, parentParser: u.parser, originalText: e, cursorOffset: void 0, rangeStart: void 0, rangeEnd: void 0 }, { passThrough: true }), { ast: n } = await Fe(e, o), a = await r(n, o);
  return qe(a);
}
function Sa(e, t, u, r) {
  let { originalText: o, [Symbol.for("comments")]: n, locStart: a, locEnd: s, [Symbol.for("printedComments")]: i } = t, { node: D } = e, f = a(D), l = s(D);
  for (let c of n) a(c) >= f && s(c) <= l && i.add(c);
  let { printPrettierIgnored: d } = t.printer;
  return d ? d(e, t, u, r) : o.slice(f, l);
}
var hn = Sa;
async function Ge(e, t) {
  ({ ast: e } = await xu(e, t));
  let u = /* @__PURE__ */ new Map(), r = new pr(e), o = Nr(t), n = /* @__PURE__ */ new Map();
  await Cn(r, s, t, Ge, n);
  let a = await gn(r, t, s, void 0, n);
  if (Tr(t), t.cursorOffset >= 0) {
    if (t.nodeAfterCursor && !t.nodeBeforeCursor) return [ee, a];
    if (t.nodeBeforeCursor && !t.nodeAfterCursor) return [a, ee];
  }
  return a;
  function s(D, f) {
    return D === void 0 || D === r ? i(f) : Array.isArray(D) ? r.call(() => i(f), ...D) : r.call(() => i(f), D);
  }
  function i(D) {
    o(r);
    let f = r.node;
    if (f == null) return "";
    let l = ge(f) && D === void 0;
    if (l && u.has(f)) return u.get(f);
    let d = gn(r, t, s, D, n);
    return l && u.set(f, d), d;
  }
}
function gn(e, t, u, r, o) {
  var _a3, _b;
  let { node: n } = e, { printer: a } = t, s;
  switch (((_a3 = a.hasPrettierIgnore) == null ? void 0 : _a3.call(a, e)) ? s = hn(e, t, u, r) : o.has(n) ? s = o.get(n) : s = a.print(e, t, u, r), n) {
    case t.cursorNode:
      s = Ee(s, (i) => [ee, i, ee]);
      break;
    case t.nodeBeforeCursor:
      s = Ee(s, (i) => [i, ee]);
      break;
    case t.nodeAfterCursor:
      s = Ee(s, (i) => [ee, i]);
      break;
  }
  return a.printComment && !((_b = a.willPrintOwnComments) == null ? void 0 : _b.call(a, e, t)) && (s = Br(e, s, t)), s;
}
async function xu(e, t) {
  let u = e.comments ?? [];
  t[Symbol.for("comments")] = u, t[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Ar(e, t);
  let { printer: { preprocess: r } } = t;
  return e = r ? await r(e, t) : e, { ast: e, comments: u };
}
function wa(e, t) {
  let { cursorOffset: u, locStart: r, locEnd: o, getVisitorKeys: n } = t, a = (c) => r(c) <= u && o(c) >= u, s = e, i = [e];
  for (let c of Cr(e, { getVisitorKeys: n, filter: a })) i.push(c), s = c;
  if (hr(s, { getVisitorKeys: n })) return { cursorNode: s };
  let D, f, l = -1, d = Number.POSITIVE_INFINITY;
  for (; i.length > 0 && (D === void 0 || f === void 0); ) {
    s = i.pop();
    let c = D !== void 0, p = f !== void 0;
    for (let F of be(s, { getVisitorKeys: n })) {
      if (!c) {
        let C = o(F);
        C <= u && C > l && (D = F, l = C);
      }
      if (!p) {
        let C = r(F);
        C >= u && C < d && (f = F, d = C);
      }
    }
  }
  return { nodeBeforeCursor: D, nodeAfterCursor: f };
}
var Bu = wa;
function Oa(e, t) {
  let { printer: u } = t, r = u.massageAstNode;
  if (!r) return e;
  let { getVisitorKeys: o } = u, { ignoredProperties: n } = r;
  return a(e);
  function a(s, i) {
    if (!ge(s)) return s;
    if (Array.isArray(s)) return s.map((d) => a(d, i)).filter(Boolean);
    let D = {}, f = new Set(o(s));
    for (let d in s) !Object.prototype.hasOwnProperty.call(s, d) || (n == null ? void 0 : n.has(d)) || (f.has(d) ? D[d] = a(s[d], s) : D[d] = s[d]);
    let l = r(s, D, i);
    if (l !== null) return l ?? D;
  }
}
var yn = Oa;
var Pa = Array.prototype.findLastIndex ?? function(e) {
  for (let t = this.length - 1; t >= 0; t--) {
    let u = this[t];
    if (e(u, t, this)) return t;
  }
  return -1;
};
var Ia = X("findLastIndex", function() {
  if (Array.isArray(this)) return Pa;
});
var bn = Ia;
var ka = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
function va(e, t) {
  return t = new Set(t), e.find((u) => xn.has(u.type) && t.has(u));
}
function An(e) {
  let t = bn(0, e, (u) => u.type !== "Program" && u.type !== "File");
  return t === -1 ? e : e.slice(0, t + 1);
}
function Ra(e, t, { locStart: u, locEnd: r }) {
  let [o, ...n] = e, [a, ...s] = t;
  if (o === a) return [o, a];
  let i = u(o);
  for (let f of An(s)) if (u(f) >= i) a = f;
  else break;
  let D = r(a);
  for (let f of An(n)) {
    if (r(f) <= D) o = f;
    else break;
    if (o === a) break;
  }
  return [o, a];
}
function Tu(e, t, u, r, o = [], n) {
  let { locStart: a, locEnd: s } = u, i = a(e), D = s(e);
  if (t > D || t < i || n === "rangeEnd" && t === i || n === "rangeStart" && t === D) return;
  let f = [e, ...o], l = at(e, f, { cache: uu, locStart: a, locEnd: s, getVisitorKeys: u.getVisitorKeys, filter: u.printer.canAttachComment, getChildren: u.printer.getCommentChildNodes });
  for (let d of l) {
    let c = Tu(d, t, u, r, f, n);
    if (c) return c;
  }
  if (r(e, o[0])) return f;
}
function La(e, t) {
  return t !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
}
var xn = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
var Ma = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function _n(e, t, u) {
  if (!t) return false;
  switch (e.parser) {
    case "flow":
    case "hermes":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "oxc":
    case "oxc-ts":
    case "__babel_estree":
      return La(t.type, u == null ? void 0 : u.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return xn.has(t.type);
    case "graphql":
      return Ma.has(t.kind);
    case "vue":
      return t.tag !== "root";
  }
  return false;
}
function Bn(e, t, u) {
  let { rangeStart: r, rangeEnd: o, locStart: n, locEnd: a } = t;
  P(o > r);
  let s = e.slice(r, o).search(/\S/u), i = s === -1;
  if (!i) for (r += s; o > r && !/\S/u.test(e[o - 1]); --o) ;
  let D = Tu(u, r, t, (c, p) => _n(t, c, p), [], "rangeStart");
  if (!D) return;
  let f = i ? D : Tu(u, o, t, (c) => _n(t, c), [], "rangeEnd");
  if (!f) return;
  let l, d;
  if (ka(t)) {
    let c = va(D, f);
    l = c, d = c;
  } else [l, d] = Ra(D, f, t);
  return [Math.min(n(l), n(d)), Math.max(a(l), a(d))];
}
var wn = "\uFEFF";
var Tn = Symbol("cursor");
async function On(e, t, u = 0) {
  if (!e || e.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: r, text: o } = await Fe(e, t);
  t.cursorOffset >= 0 && (t = { ...t, ...Bu(r, t) });
  let n = await Ge(r, t, u);
  u > 0 && (n = tt([V, n], u, t.tabWidth));
  let a = Ce(n, t);
  if (u > 0) {
    let i = a.formatted.trim();
    a.cursorNodeStart !== void 0 && (a.cursorNodeStart -= a.formatted.indexOf(i), a.cursorNodeStart < 0 && (a.cursorNodeStart = 0, a.cursorNodeText = a.cursorNodeText.trimStart()), a.cursorNodeStart + a.cursorNodeText.length > i.length && (a.cursorNodeText = a.cursorNodeText.trimEnd())), a.formatted = i + Se(t.endOfLine);
  }
  let s = t[Symbol.for("comments")];
  if (t.cursorOffset >= 0) {
    let i, D, f, l;
    if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && a.cursorNodeText) if (f = a.cursorNodeStart, l = a.cursorNodeText, t.cursorNode) i = t.locStart(t.cursorNode), D = o.slice(i, t.locEnd(t.cursorNode));
    else {
      if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
      i = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
      let y = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : o.length;
      D = o.slice(i, y);
    }
    else i = 0, D = o, f = 0, l = a.formatted;
    let d = t.cursorOffset - i;
    if (D === l) return { formatted: a.formatted, cursorOffset: f + d, comments: s };
    let c = D.split("");
    c.splice(d, 0, Tn);
    let p = l.split(""), F = Ut(c, p), C = f;
    for (let y of F) if (y.removed) {
      if (y.value.includes(Tn)) break;
    } else C += y.count;
    return { formatted: a.formatted, cursorOffset: C, comments: s };
  }
  return { formatted: a.formatted, cursorOffset: -1, comments: s };
}
async function Ya(e, t) {
  let { ast: u, text: r } = await Fe(e, t), [o, n] = Bn(r, t, u) ?? [0, 0], a = r.slice(o, n), s = Math.min(o, r.lastIndexOf(`
`, o) + 1), i = r.slice(s, o).match(/^\s*/u)[0], D = he(i, t.tabWidth), f = await On(a, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > o && t.cursorOffset <= n ? t.cursorOffset - o : -1, endOfLine: "lf" }, D), l = f.formatted.trimEnd(), { cursorOffset: d } = t;
  d > n ? d += l.length - a.length : f.cursorOffset >= 0 && (d = f.cursorOffset + o);
  let c = r.slice(0, o) + l + r.slice(n);
  if (t.endOfLine !== "lf") {
    let p = Se(t.endOfLine);
    d >= 0 && p === `\r
` && (d += $t(c.slice(0, d), `
`)), c = oe(0, c, `
`, p);
  }
  return { formatted: c, cursorOffset: d, comments: f.comments };
}
function Nu(e, t, u) {
  return typeof t != "number" || Number.isNaN(t) || t < 0 || t > e.length ? u : t;
}
function Nn(e, t) {
  let { cursorOffset: u, rangeStart: r, rangeEnd: o } = t;
  return u = Nu(e, u, -1), r = Nu(e, r, 0), o = Nu(e, o, e.length), { ...t, cursorOffset: u, rangeStart: r, rangeEnd: o };
}
function Pn(e, t) {
  let { cursorOffset: u, rangeStart: r, rangeEnd: o, endOfLine: n } = Nn(e, t), a = e.charAt(0) === wn;
  if (a && (e = e.slice(1), u--, r--, o--), n === "auto" && (n = Yu(e)), e.includes("\r")) {
    let s = (i) => $t(e.slice(0, Math.max(i, 0)), `\r
`);
    u -= s(u), r -= s(r), o -= s(o), e = ju(e);
  }
  return { hasBOM: a, text: e, options: Nn(e, { ...t, cursorOffset: u, rangeStart: r, rangeEnd: o, endOfLine: n }) };
}
async function Sn(e, t) {
  let u = await We(t);
  return !u.hasPragma || u.hasPragma(e);
}
async function ja(e, t) {
  var _a3, _b;
  return (_b = (_a3 = await We(t)).hasIgnorePragma) == null ? void 0 : _b.call(_a3, e);
}
async function Su(e, t) {
  let { hasBOM: u, text: r, options: o } = Pn(e, await se(t));
  if (o.rangeStart >= o.rangeEnd && r !== "" || o.requirePragma && !await Sn(r, o) || o.checkIgnorePragma && await ja(r, o)) return { formatted: e, cursorOffset: t.cursorOffset, comments: [] };
  let n;
  return o.rangeStart > 0 || o.rangeEnd < r.length ? n = await Ya(r, o) : (!o.requirePragma && o.insertPragma && o.printer.insertPragma && !await Sn(r, o) && (r = o.printer.insertPragma(r)), n = await On(r, o)), u && (n.formatted = wn + n.formatted, n.cursorOffset >= 0 && n.cursorOffset++), n;
}
async function In(e, t, u) {
  let { text: r, options: o } = Pn(e, await se(t)), n = await Fe(r, o);
  return u && (u.preprocessForPrint && (n.ast = await xu(n.ast, o)), u.massage && (n.ast = yn(n.ast, o))), n;
}
async function kn(e, t) {
  t = await se(t);
  let u = await Ge(e, t);
  return Ce(u, t);
}
async function vn(e, t) {
  let u = sr(e), { formatted: r } = await Su(u, { ...t, parser: "__js_expression" });
  return r;
}
async function Rn(e, t) {
  t = await se(t);
  let { ast: u } = await Fe(e, t);
  return t.cursorOffset >= 0 && (t = { ...t, ...Bu(u, t) }), Ge(u, t);
}
async function Ln(e, t) {
  return Ce(e, await se(t));
}
var wu = {};
Yt(wu, { builders: () => Wa, printer: () => $a, utils: () => Va });
var Wa = { join: Ie, line: ut, softline: or, hardline: V, literalline: Qe, group: Kt, conditionalGroup: tr, fill: er, lineSuffix: ve, lineSuffixBoundary: ar, cursor: ee, breakParent: ce, ifBreak: ur, trim: ir, indent: ae, indentIfBreak: rr, align: De, addAlignmentToDoc: tt, markAsRoot: et, dedentToRoot: Qu, dedent: Zu, hardlineWithoutBreakParent: ke, literallineWithoutBreakParent: Gt, label: nr, concat: (e) => e };
var $a = { printDocToString: Ce };
var Va = { willBreak: Ku, traverseDoc: we, findInDoc: Xe, mapDoc: Pe, removeLines: zu, stripTrailingHardline: qe, replaceEndOfLine: Ju, canBreak: Hu };
var Mn = "3.8.1";
var Pu = {};
Yt(Pu, { addDanglingComment: () => ue, addLeadingComment: () => fe, addTrailingComment: () => le, getAlignmentSize: () => he, getIndentSize: () => Yn, getMaxContinuousCount: () => jn, getNextNonSpaceNonCommentCharacter: () => Un, getNextNonSpaceNonCommentCharacterIndex: () => ni, getPreferredQuote: () => Vn, getStringWidth: () => Re, hasNewline: () => z, hasNewlineInRange: () => Kn, hasSpaces: () => Gn, isNextLineEmpty: () => Di, isNextLineEmptyAfterIndex: () => kt, isPreviousLineEmpty: () => ai, makeString: () => si, skip: () => ye, skipEverythingButNewLine: () => ot, skipInlineComment: () => xe, skipNewline: () => K, skipSpaces: () => Y, skipToLineEnd: () => nt, skipTrailingComment: () => Be, skipWhitespace: () => Fr });
function Ka(e, t) {
  if (t === false) return false;
  if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
    for (let u = t + 2; u < e.length; ++u) if (e.charAt(u) === "*" && e.charAt(u + 1) === "/") return u + 2;
  }
  return t;
}
var xe = Ka;
function Ga(e, t) {
  return t === false ? false : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? ot(e, t) : t;
}
var Be = Ga;
function za(e, t) {
  let u = null, r = t;
  for (; r !== u; ) u = r, r = Y(e, r), r = xe(e, r), r = Be(e, r), r = K(e, r);
  return r;
}
var ze = za;
function Ja(e, t) {
  let u = null, r = t;
  for (; r !== u; ) u = r, r = nt(e, r), r = xe(e, r), r = Y(e, r);
  return r = Be(e, r), r = K(e, r), r !== false && z(e, r);
}
var kt = Ja;
function Ha(e, t) {
  let u = e.lastIndexOf(`
`);
  return u === -1 ? 0 : he(e.slice(u + 1).match(/^[\t ]*/u)[0], t);
}
var Yn = Ha;
function Ou(e) {
  if (typeof e != "string") throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Xa(e, t) {
  let u = e.matchAll(new RegExp(`(?:${Ou(t)})+`, "gu"));
  return u.reduce || (u = [...u]), u.reduce((r, [o]) => Math.max(r, o.length), 0) / t.length;
}
var jn = Xa;
function qa(e, t) {
  let u = ze(e, t);
  return u === false ? "" : e.charAt(u);
}
var Un = qa;
var Wn = Object.freeze({ character: "'", codePoint: 39 });
var $n = Object.freeze({ character: '"', codePoint: 34 });
var Qa = Object.freeze({ preferred: Wn, alternate: $n });
var Za = Object.freeze({ preferred: $n, alternate: Wn });
function ei(e, t) {
  let { preferred: u, alternate: r } = t === true || t === "'" ? Qa : Za, { length: o } = e, n = 0, a = 0;
  for (let s = 0; s < o; s++) {
    let i = e.charCodeAt(s);
    i === u.codePoint ? n++ : i === r.codePoint && a++;
  }
  return (n > a ? r : u).character;
}
var Vn = ei;
function ti(e, t, u) {
  for (let r = t; r < u; ++r) if (e.charAt(r) === `
`) return true;
  return false;
}
var Kn = ti;
function ui(e, t, u = {}) {
  return Y(e, u.backwards ? t - 1 : t, u) !== t;
}
var Gn = ui;
function ri(e, t, u) {
  return ze(e, u(t));
}
function ni(e, t) {
  return arguments.length === 2 || typeof t == "number" ? ze(e, t) : ri(...arguments);
}
function oi(e, t, u) {
  return Le(e, u(t));
}
function ai(e, t) {
  return arguments.length === 2 || typeof t == "number" ? Le(e, t) : oi(...arguments);
}
function ii(e, t, u) {
  return kt(e, u(t));
}
function si(e, t, u) {
  let r = t === '"' ? "'" : '"', n = oe(0, e, /\\(.)|(["'])/gsu, (a, s, i) => s === r ? s : i === t ? "\\" + i : i || (u && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
  return t + n + t;
}
function Di(e, t) {
  return arguments.length === 2 || typeof t == "number" ? kt(e, t) : ii(...arguments);
}
function me(e, t = 1) {
  return async (...u) => {
    let r = u[t] ?? {}, o = r.plugins ?? [];
    return u[t] = { ...r, plugins: Array.isArray(o) ? o : Object.values(o) }, e(...u);
  };
}
var zn = me(Su);
async function Jn(e, t) {
  let { formatted: u } = await zn(e, { ...t, cursorOffset: -1 });
  return u;
}
async function ci(e, t) {
  return await Jn(e, t) === e;
}
var fi = me(it, 0);
var li = { parse: me(In), formatAST: me(kn), formatDoc: me(vn), printToDoc: me(Rn), printDocToString: me(Ln) };
export {
  li as __debug,
  ci as check,
  Hn as default,
  wu as doc,
  Jn as format,
  zn as formatWithCursor,
  fi as getSupportInfo,
  Pu as util,
  Mn as version
};
//# sourceMappingURL=@slidev_cli___@slidev_client___prettier.js.map
